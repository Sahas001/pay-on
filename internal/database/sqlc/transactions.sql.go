// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: transactions.sql

package database

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const checkNonceExists = `-- name: CheckNonceExists :one
SELECT EXISTS(
    SELECT 1 FROM transactions
    WHERE from_wallet_id = $1 AND nonce = $2
)
`

type CheckNonceExistsParams struct {
	FromWalletID uuid.UUID `json:"from_wallet_id"`
	Nonce        int64     `json:"nonce"`
}

func (q *Queries) CheckNonceExists(ctx context.Context, arg CheckNonceExistsParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkNonceExists, arg.FromWalletID, arg.Nonce)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const confirmTransaction = `-- name: ConfirmTransaction :one
UPDATE transactions
SET 
    status = 'confirmed',
    confirmed_at = NOW(),
    updated_at = NOW()
WHERE id = $1
RETURNING id, from_wallet_id, to_wallet_id, amount, currency, type, status, signature, nonce, connection_type, description, metadata, transaction_at, confirmed_at, synced_at, created_at, updated_at
`

func (q *Queries) ConfirmTransaction(ctx context.Context, id uuid.UUID) (Transaction, error) {
	row := q.db.QueryRow(ctx, confirmTransaction, id)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.FromWalletID,
		&i.ToWalletID,
		&i.Amount,
		&i.Currency,
		&i.Type,
		&i.Status,
		&i.Signature,
		&i.Nonce,
		&i.ConnectionType,
		&i.Description,
		&i.Metadata,
		&i.TransactionAt,
		&i.ConfirmedAt,
		&i.SyncedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const countPendingTransactions = `-- name: CountPendingTransactions :one
SELECT COUNT(*) FROM transactions
WHERE status = 'pending'
`

func (q *Queries) CountPendingTransactions(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countPendingTransactions)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countTransactionsByWallet = `-- name: CountTransactionsByWallet :one
SELECT COUNT(*) FROM transactions
WHERE (from_wallet_id = $1 OR to_wallet_id = $1)
`

func (q *Queries) CountTransactionsByWallet(ctx context.Context, fromWalletID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countTransactionsByWallet, fromWalletID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createTransaction = `-- name: CreateTransaction :one

INSERT INTO transactions (
    from_wallet_id,
    to_wallet_id,
    amount,
    currency,
    type,
    status,
    signature,
    nonce,
    connection_type,
    description,
    metadata,
    transaction_at
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12
) RETURNING id, from_wallet_id, to_wallet_id, amount, currency, type, status, signature, nonce, connection_type, description, metadata, transaction_at, confirmed_at, synced_at, created_at, updated_at
`

type CreateTransactionParams struct {
	FromWalletID   uuid.UUID          `json:"from_wallet_id"`
	ToWalletID     uuid.UUID          `json:"to_wallet_id"`
	Amount         pgtype.Numeric     `json:"amount"`
	Currency       string             `json:"currency"`
	Type           TransactionType    `json:"type"`
	Status         TransactionStatus  `json:"status"`
	Signature      string             `json:"signature"`
	Nonce          int64              `json:"nonce"`
	ConnectionType NullConnectionType `json:"connection_type"`
	Description    *string            `json:"description"`
	Metadata       []byte             `json:"metadata"`
	TransactionAt  pgtype.Timestamptz `json:"transaction_at"`
}

// internal/database/query/transactions.sql
func (q *Queries) CreateTransaction(ctx context.Context, arg CreateTransactionParams) (Transaction, error) {
	row := q.db.QueryRow(ctx, createTransaction,
		arg.FromWalletID,
		arg.ToWalletID,
		arg.Amount,
		arg.Currency,
		arg.Type,
		arg.Status,
		arg.Signature,
		arg.Nonce,
		arg.ConnectionType,
		arg.Description,
		arg.Metadata,
		arg.TransactionAt,
	)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.FromWalletID,
		&i.ToWalletID,
		&i.Amount,
		&i.Currency,
		&i.Type,
		&i.Status,
		&i.Signature,
		&i.Nonce,
		&i.ConnectionType,
		&i.Description,
		&i.Metadata,
		&i.TransactionAt,
		&i.ConfirmedAt,
		&i.SyncedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const failTransaction = `-- name: FailTransaction :exec
UPDATE transactions
SET 
    status = 'failed',
    updated_at = NOW()
WHERE id = $1
`

func (q *Queries) FailTransaction(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, failTransaction, id)
	return err
}

const getDailyTransactionSummary = `-- name: GetDailyTransactionSummary :many
SELECT 
    DATE(transaction_at) as date,
    COUNT(*) as transaction_count,
    SUM(CASE WHEN from_wallet_id = $1 THEN amount ELSE 0 END) as total_sent,
    SUM(CASE WHEN to_wallet_id = $1 THEN amount ELSE 0 END) as total_received,
    SUM(CASE WHEN to_wallet_id = $1 THEN amount ELSE -amount END) as net_amount
FROM transactions
WHERE (from_wallet_id = $1 OR to_wallet_id = $1)
  AND status IN ('confirmed', 'settled')
  AND transaction_at >= CURRENT_DATE - INTERVAL '30 days'
GROUP BY DATE(transaction_at)
ORDER BY date DESC
`

type GetDailyTransactionSummaryRow struct {
	Date             pgtype.Date `json:"date"`
	TransactionCount int64       `json:"transaction_count"`
	TotalSent        int64       `json:"total_sent"`
	TotalReceived    int64       `json:"total_received"`
	NetAmount        int64       `json:"net_amount"`
}

func (q *Queries) GetDailyTransactionSummary(ctx context.Context, fromWalletID uuid.UUID) ([]GetDailyTransactionSummaryRow, error) {
	rows, err := q.db.Query(ctx, getDailyTransactionSummary, fromWalletID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetDailyTransactionSummaryRow{}
	for rows.Next() {
		var i GetDailyTransactionSummaryRow
		if err := rows.Scan(
			&i.Date,
			&i.TransactionCount,
			&i.TotalSent,
			&i.TotalReceived,
			&i.NetAmount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLargeTransactions = `-- name: GetLargeTransactions :many
SELECT id, from_wallet_id, to_wallet_id, amount, currency, type, status, signature, nonce, connection_type, description, metadata, transaction_at, confirmed_at, synced_at, created_at, updated_at FROM transactions
WHERE amount >= $1
  AND status IN ('confirmed', 'settled')
ORDER BY amount DESC, transaction_at DESC
LIMIT $2
`

type GetLargeTransactionsParams struct {
	Amount pgtype.Numeric `json:"amount"`
	Limit  int32          `json:"limit"`
}

func (q *Queries) GetLargeTransactions(ctx context.Context, arg GetLargeTransactionsParams) ([]Transaction, error) {
	rows, err := q.db.Query(ctx, getLargeTransactions, arg.Amount, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Transaction{}
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.FromWalletID,
			&i.ToWalletID,
			&i.Amount,
			&i.Currency,
			&i.Type,
			&i.Status,
			&i.Signature,
			&i.Nonce,
			&i.ConnectionType,
			&i.Description,
			&i.Metadata,
			&i.TransactionAt,
			&i.ConfirmedAt,
			&i.SyncedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentTransactions = `-- name: GetRecentTransactions :many
SELECT 
    t.id, t.from_wallet_id, t.to_wallet_id, t.amount, t.currency, t.type, t.status, t.signature, t.nonce, t.connection_type, t.description, t.metadata, t.transaction_at, t.confirmed_at, t.synced_at, t.created_at, t.updated_at,
    w_from.name as from_wallet_name,
    w_to.name as to_wallet_name
FROM transactions t
JOIN wallets w_from ON t.from_wallet_id = w_from. id
JOIN wallets w_to ON t.to_wallet_id = w_to.id
WHERE t.transaction_at >= NOW() - INTERVAL '24 hours'
  AND t. status IN ('confirmed', 'settled')
ORDER BY t.transaction_at DESC
LIMIT $1
`

type GetRecentTransactionsRow struct {
	ID             uuid.UUID          `json:"id"`
	FromWalletID   uuid.UUID          `json:"from_wallet_id"`
	ToWalletID     uuid.UUID          `json:"to_wallet_id"`
	Amount         pgtype.Numeric     `json:"amount"`
	Currency       string             `json:"currency"`
	Type           TransactionType    `json:"type"`
	Status         TransactionStatus  `json:"status"`
	Signature      string             `json:"signature"`
	Nonce          int64              `json:"nonce"`
	ConnectionType NullConnectionType `json:"connection_type"`
	Description    *string            `json:"description"`
	Metadata       []byte             `json:"metadata"`
	TransactionAt  pgtype.Timestamptz `json:"transaction_at"`
	ConfirmedAt    pgtype.Timestamptz `json:"confirmed_at"`
	SyncedAt       pgtype.Timestamptz `json:"synced_at"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	UpdatedAt      pgtype.Timestamptz `json:"updated_at"`
	FromWalletName string             `json:"from_wallet_name"`
	ToWalletName   string             `json:"to_wallet_name"`
}

func (q *Queries) GetRecentTransactions(ctx context.Context, limit int32) ([]GetRecentTransactionsRow, error) {
	rows, err := q.db.Query(ctx, getRecentTransactions, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRecentTransactionsRow{}
	for rows.Next() {
		var i GetRecentTransactionsRow
		if err := rows.Scan(
			&i.ID,
			&i.FromWalletID,
			&i.ToWalletID,
			&i.Amount,
			&i.Currency,
			&i.Type,
			&i.Status,
			&i.Signature,
			&i.Nonce,
			&i.ConnectionType,
			&i.Description,
			&i.Metadata,
			&i.TransactionAt,
			&i.ConfirmedAt,
			&i.SyncedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.FromWalletName,
			&i.ToWalletName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTransactionByID = `-- name: GetTransactionByID :one
SELECT id, from_wallet_id, to_wallet_id, amount, currency, type, status, signature, nonce, connection_type, description, metadata, transaction_at, confirmed_at, synced_at, created_at, updated_at FROM transactions
WHERE id = $1
`

func (q *Queries) GetTransactionByID(ctx context.Context, id uuid.UUID) (Transaction, error) {
	row := q.db.QueryRow(ctx, getTransactionByID, id)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.FromWalletID,
		&i.ToWalletID,
		&i.Amount,
		&i.Currency,
		&i.Type,
		&i.Status,
		&i.Signature,
		&i.Nonce,
		&i.ConnectionType,
		&i.Description,
		&i.Metadata,
		&i.TransactionAt,
		&i.ConfirmedAt,
		&i.SyncedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTransactionStats = `-- name: GetTransactionStats :one
SELECT 
    COALESCE(SUM(CASE WHEN from_wallet_id = $1 THEN amount ELSE 0 END), 0) as total_sent,
    COALESCE(SUM(CASE WHEN to_wallet_id = $1 THEN amount ELSE 0 END), 0) as total_received,
    COUNT(*) as transaction_count,
    COALESCE(SUM(CASE WHEN to_wallet_id = $1 THEN amount ELSE -amount END), 0) as net_flow,
    COALESCE(AVG(amount), 0) as avg_transaction,
    MAX(transaction_at) as last_transaction_at
FROM transactions
WHERE (from_wallet_id = $1 OR to_wallet_id = $1)
  AND status IN ('confirmed', 'settled')
`

type GetTransactionStatsRow struct {
	TotalSent         interface{} `json:"total_sent"`
	TotalReceived     interface{} `json:"total_received"`
	TransactionCount  int64       `json:"transaction_count"`
	NetFlow           interface{} `json:"net_flow"`
	AvgTransaction    interface{} `json:"avg_transaction"`
	LastTransactionAt interface{} `json:"last_transaction_at"`
}

func (q *Queries) GetTransactionStats(ctx context.Context, fromWalletID uuid.UUID) (GetTransactionStatsRow, error) {
	row := q.db.QueryRow(ctx, getTransactionStats, fromWalletID)
	var i GetTransactionStatsRow
	err := row.Scan(
		&i.TotalSent,
		&i.TotalReceived,
		&i.TransactionCount,
		&i.NetFlow,
		&i.AvgTransaction,
		&i.LastTransactionAt,
	)
	return i, err
}

const getTransactionWithWallets = `-- name: GetTransactionWithWallets :one
SELECT 
    t.id, t.from_wallet_id, t.to_wallet_id, t.amount, t.currency, t.type, t.status, t.signature, t.nonce, t.connection_type, t.description, t.metadata, t.transaction_at, t.confirmed_at, t.synced_at, t.created_at, t.updated_at,
    w_from.name as from_wallet_name,
    w_from.phone_number as from_wallet_phone,
    w_to.name as to_wallet_name,
    w_to.phone_number as to_wallet_phone
FROM transactions t
JOIN wallets w_from ON t.from_wallet_id = w_from.id
JOIN wallets w_to ON t.to_wallet_id = w_to.id
WHERE t.id = $1
`

type GetTransactionWithWalletsRow struct {
	ID              uuid.UUID          `json:"id"`
	FromWalletID    uuid.UUID          `json:"from_wallet_id"`
	ToWalletID      uuid.UUID          `json:"to_wallet_id"`
	Amount          pgtype.Numeric     `json:"amount"`
	Currency        string             `json:"currency"`
	Type            TransactionType    `json:"type"`
	Status          TransactionStatus  `json:"status"`
	Signature       string             `json:"signature"`
	Nonce           int64              `json:"nonce"`
	ConnectionType  NullConnectionType `json:"connection_type"`
	Description     *string            `json:"description"`
	Metadata        []byte             `json:"metadata"`
	TransactionAt   pgtype.Timestamptz `json:"transaction_at"`
	ConfirmedAt     pgtype.Timestamptz `json:"confirmed_at"`
	SyncedAt        pgtype.Timestamptz `json:"synced_at"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `json:"updated_at"`
	FromWalletName  string             `json:"from_wallet_name"`
	FromWalletPhone string             `json:"from_wallet_phone"`
	ToWalletName    string             `json:"to_wallet_name"`
	ToWalletPhone   string             `json:"to_wallet_phone"`
}

func (q *Queries) GetTransactionWithWallets(ctx context.Context, id uuid.UUID) (GetTransactionWithWalletsRow, error) {
	row := q.db.QueryRow(ctx, getTransactionWithWallets, id)
	var i GetTransactionWithWalletsRow
	err := row.Scan(
		&i.ID,
		&i.FromWalletID,
		&i.ToWalletID,
		&i.Amount,
		&i.Currency,
		&i.Type,
		&i.Status,
		&i.Signature,
		&i.Nonce,
		&i.ConnectionType,
		&i.Description,
		&i.Metadata,
		&i.TransactionAt,
		&i.ConfirmedAt,
		&i.SyncedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.FromWalletName,
		&i.FromWalletPhone,
		&i.ToWalletName,
		&i.ToWalletPhone,
	)
	return i, err
}

const getTransactionsByConnectionType = `-- name: GetTransactionsByConnectionType :many
SELECT id, from_wallet_id, to_wallet_id, amount, currency, type, status, signature, nonce, connection_type, description, metadata, transaction_at, confirmed_at, synced_at, created_at, updated_at FROM transactions
WHERE connection_type = $1
  AND transaction_at >= $2
ORDER BY transaction_at DESC
LIMIT $3
`

type GetTransactionsByConnectionTypeParams struct {
	ConnectionType NullConnectionType `json:"connection_type"`
	TransactionAt  pgtype.Timestamptz `json:"transaction_at"`
	Limit          int32              `json:"limit"`
}

func (q *Queries) GetTransactionsByConnectionType(ctx context.Context, arg GetTransactionsByConnectionTypeParams) ([]Transaction, error) {
	rows, err := q.db.Query(ctx, getTransactionsByConnectionType, arg.ConnectionType, arg.TransactionAt, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Transaction{}
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.FromWalletID,
			&i.ToWalletID,
			&i.Amount,
			&i.Currency,
			&i.Type,
			&i.Status,
			&i.Signature,
			&i.Nonce,
			&i.ConnectionType,
			&i.Description,
			&i.Metadata,
			&i.TransactionAt,
			&i.ConfirmedAt,
			&i.SyncedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTransactionsByDateRange = `-- name: GetTransactionsByDateRange :many
SELECT id, from_wallet_id, to_wallet_id, amount, currency, type, status, signature, nonce, connection_type, description, metadata, transaction_at, confirmed_at, synced_at, created_at, updated_at FROM transactions
WHERE (from_wallet_id = $1 OR to_wallet_id = $1)
  AND transaction_at BETWEEN $2 AND $3
ORDER BY transaction_at DESC
`

type GetTransactionsByDateRangeParams struct {
	FromWalletID    uuid.UUID          `json:"from_wallet_id"`
	TransactionAt   pgtype.Timestamptz `json:"transaction_at"`
	TransactionAt_2 pgtype.Timestamptz `json:"transaction_at_2"`
}

func (q *Queries) GetTransactionsByDateRange(ctx context.Context, arg GetTransactionsByDateRangeParams) ([]Transaction, error) {
	rows, err := q.db.Query(ctx, getTransactionsByDateRange, arg.FromWalletID, arg.TransactionAt, arg.TransactionAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Transaction{}
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.FromWalletID,
			&i.ToWalletID,
			&i.Amount,
			&i.Currency,
			&i.Type,
			&i.Status,
			&i.Signature,
			&i.Nonce,
			&i.ConnectionType,
			&i.Description,
			&i.Metadata,
			&i.TransactionAt,
			&i.ConfirmedAt,
			&i.SyncedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTransactionsByMetadata = `-- name: GetTransactionsByMetadata :many
SELECT id, from_wallet_id, to_wallet_id, amount, currency, type, status, signature, nonce, connection_type, description, metadata, transaction_at, confirmed_at, synced_at, created_at, updated_at FROM transactions
WHERE metadata @> $1:: jsonb
ORDER BY transaction_at DESC
LIMIT $2 OFFSET $3
`

type GetTransactionsByMetadataParams struct {
	Column1 []byte `json:"column_1"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

func (q *Queries) GetTransactionsByMetadata(ctx context.Context, arg GetTransactionsByMetadataParams) ([]Transaction, error) {
	rows, err := q.db.Query(ctx, getTransactionsByMetadata, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Transaction{}
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.FromWalletID,
			&i.ToWalletID,
			&i.Amount,
			&i.Currency,
			&i.Type,
			&i.Status,
			&i.Signature,
			&i.Nonce,
			&i.ConnectionType,
			&i.Description,
			&i.Metadata,
			&i.TransactionAt,
			&i.ConfirmedAt,
			&i.SyncedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPendingTransactions = `-- name: ListPendingTransactions :many
SELECT id, from_wallet_id, to_wallet_id, amount, currency, type, status, signature, nonce, connection_type, description, metadata, transaction_at, confirmed_at, synced_at, created_at, updated_at FROM transactions
WHERE status IN ('pending', 'confirmed')
  AND (from_wallet_id = $1 OR to_wallet_id = $1)
ORDER BY created_at ASC
LIMIT $2
`

type ListPendingTransactionsParams struct {
	FromWalletID uuid.UUID `json:"from_wallet_id"`
	Limit        int32     `json:"limit"`
}

func (q *Queries) ListPendingTransactions(ctx context.Context, arg ListPendingTransactionsParams) ([]Transaction, error) {
	rows, err := q.db.Query(ctx, listPendingTransactions, arg.FromWalletID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Transaction{}
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.FromWalletID,
			&i.ToWalletID,
			&i.Amount,
			&i.Currency,
			&i.Type,
			&i.Status,
			&i.Signature,
			&i.Nonce,
			&i.ConnectionType,
			&i.Description,
			&i.Metadata,
			&i.TransactionAt,
			&i.ConfirmedAt,
			&i.SyncedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listReceivedTransactions = `-- name: ListReceivedTransactions :many
SELECT id, from_wallet_id, to_wallet_id, amount, currency, type, status, signature, nonce, connection_type, description, metadata, transaction_at, confirmed_at, synced_at, created_at, updated_at FROM transactions
WHERE to_wallet_id = $1
ORDER BY transaction_at DESC
LIMIT $2 OFFSET $3
`

type ListReceivedTransactionsParams struct {
	ToWalletID uuid.UUID `json:"to_wallet_id"`
	Limit      int32     `json:"limit"`
	Offset     int32     `json:"offset"`
}

func (q *Queries) ListReceivedTransactions(ctx context.Context, arg ListReceivedTransactionsParams) ([]Transaction, error) {
	rows, err := q.db.Query(ctx, listReceivedTransactions, arg.ToWalletID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Transaction{}
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.FromWalletID,
			&i.ToWalletID,
			&i.Amount,
			&i.Currency,
			&i.Type,
			&i.Status,
			&i.Signature,
			&i.Nonce,
			&i.ConnectionType,
			&i.Description,
			&i.Metadata,
			&i.TransactionAt,
			&i.ConfirmedAt,
			&i.SyncedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSentTransactions = `-- name: ListSentTransactions :many
SELECT id, from_wallet_id, to_wallet_id, amount, currency, type, status, signature, nonce, connection_type, description, metadata, transaction_at, confirmed_at, synced_at, created_at, updated_at FROM transactions
WHERE from_wallet_id = $1
ORDER BY transaction_at DESC
LIMIT $2 OFFSET $3
`

type ListSentTransactionsParams struct {
	FromWalletID uuid.UUID `json:"from_wallet_id"`
	Limit        int32     `json:"limit"`
	Offset       int32     `json:"offset"`
}

func (q *Queries) ListSentTransactions(ctx context.Context, arg ListSentTransactionsParams) ([]Transaction, error) {
	rows, err := q.db.Query(ctx, listSentTransactions, arg.FromWalletID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Transaction{}
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.FromWalletID,
			&i.ToWalletID,
			&i.Amount,
			&i.Currency,
			&i.Type,
			&i.Status,
			&i.Signature,
			&i.Nonce,
			&i.ConnectionType,
			&i.Description,
			&i.Metadata,
			&i.TransactionAt,
			&i.ConfirmedAt,
			&i.SyncedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTransactionsByStatus = `-- name: ListTransactionsByStatus :many
SELECT id, from_wallet_id, to_wallet_id, amount, currency, type, status, signature, nonce, connection_type, description, metadata, transaction_at, confirmed_at, synced_at, created_at, updated_at FROM transactions
WHERE status = $1
ORDER BY created_at ASC
LIMIT $2 OFFSET $3
`

type ListTransactionsByStatusParams struct {
	Status TransactionStatus `json:"status"`
	Limit  int32             `json:"limit"`
	Offset int32             `json:"offset"`
}

func (q *Queries) ListTransactionsByStatus(ctx context.Context, arg ListTransactionsByStatusParams) ([]Transaction, error) {
	rows, err := q.db.Query(ctx, listTransactionsByStatus, arg.Status, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Transaction{}
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.FromWalletID,
			&i.ToWalletID,
			&i.Amount,
			&i.Currency,
			&i.Type,
			&i.Status,
			&i.Signature,
			&i.Nonce,
			&i.ConnectionType,
			&i.Description,
			&i.Metadata,
			&i.TransactionAt,
			&i.ConfirmedAt,
			&i.SyncedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTransactionsByWallet = `-- name: ListTransactionsByWallet :many
SELECT 
    t.id, t.from_wallet_id, t.to_wallet_id, t.amount, t.currency, t.type, t.status, t.signature, t.nonce, t.connection_type, t.description, t.metadata, t.transaction_at, t.confirmed_at, t.synced_at, t.created_at, t.updated_at,
    CASE 
        WHEN t.from_wallet_id = $1 THEN 'SENT'
        WHEN t.to_wallet_id = $1 THEN 'RECEIVED'
    END as direction
FROM transactions t
WHERE (t.from_wallet_id = $1 OR t.to_wallet_id = $1)
ORDER BY t.transaction_at DESC
LIMIT $2 OFFSET $3
`

type ListTransactionsByWalletParams struct {
	FromWalletID uuid.UUID `json:"from_wallet_id"`
	Limit        int32     `json:"limit"`
	Offset       int32     `json:"offset"`
}

type ListTransactionsByWalletRow struct {
	ID             uuid.UUID          `json:"id"`
	FromWalletID   uuid.UUID          `json:"from_wallet_id"`
	ToWalletID     uuid.UUID          `json:"to_wallet_id"`
	Amount         pgtype.Numeric     `json:"amount"`
	Currency       string             `json:"currency"`
	Type           TransactionType    `json:"type"`
	Status         TransactionStatus  `json:"status"`
	Signature      string             `json:"signature"`
	Nonce          int64              `json:"nonce"`
	ConnectionType NullConnectionType `json:"connection_type"`
	Description    *string            `json:"description"`
	Metadata       []byte             `json:"metadata"`
	TransactionAt  pgtype.Timestamptz `json:"transaction_at"`
	ConfirmedAt    pgtype.Timestamptz `json:"confirmed_at"`
	SyncedAt       pgtype.Timestamptz `json:"synced_at"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	UpdatedAt      pgtype.Timestamptz `json:"updated_at"`
	Direction      interface{}        `json:"direction"`
}

func (q *Queries) ListTransactionsByWallet(ctx context.Context, arg ListTransactionsByWalletParams) ([]ListTransactionsByWalletRow, error) {
	rows, err := q.db.Query(ctx, listTransactionsByWallet, arg.FromWalletID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListTransactionsByWalletRow{}
	for rows.Next() {
		var i ListTransactionsByWalletRow
		if err := rows.Scan(
			&i.ID,
			&i.FromWalletID,
			&i.ToWalletID,
			&i.Amount,
			&i.Currency,
			&i.Type,
			&i.Status,
			&i.Signature,
			&i.Nonce,
			&i.ConnectionType,
			&i.Description,
			&i.Metadata,
			&i.TransactionAt,
			&i.ConfirmedAt,
			&i.SyncedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Direction,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUnsyncedTransactions = `-- name: ListUnsyncedTransactions :many
SELECT id, from_wallet_id, to_wallet_id, amount, currency, type, status, signature, nonce, connection_type, description, metadata, transaction_at, confirmed_at, synced_at, created_at, updated_at FROM transactions
WHERE status IN ('pending', 'confirmed')
ORDER BY created_at ASC
LIMIT $1 OFFSET $2
`

type ListUnsyncedTransactionsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListUnsyncedTransactions(ctx context.Context, arg ListUnsyncedTransactionsParams) ([]Transaction, error) {
	rows, err := q.db.Query(ctx, listUnsyncedTransactions, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Transaction{}
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.FromWalletID,
			&i.ToWalletID,
			&i.Amount,
			&i.Currency,
			&i.Type,
			&i.Status,
			&i.Signature,
			&i.Nonce,
			&i.ConnectionType,
			&i.Description,
			&i.Metadata,
			&i.TransactionAt,
			&i.ConfirmedAt,
			&i.SyncedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markTransactionSettled = `-- name: MarkTransactionSettled :one
UPDATE transactions
SET 
    status = 'settled',
    synced_at = NOW(),
    updated_at = NOW()
WHERE id = $1
RETURNING id, from_wallet_id, to_wallet_id, amount, currency, type, status, signature, nonce, connection_type, description, metadata, transaction_at, confirmed_at, synced_at, created_at, updated_at
`

func (q *Queries) MarkTransactionSettled(ctx context.Context, id uuid.UUID) (Transaction, error) {
	row := q.db.QueryRow(ctx, markTransactionSettled, id)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.FromWalletID,
		&i.ToWalletID,
		&i.Amount,
		&i.Currency,
		&i.Type,
		&i.Status,
		&i.Signature,
		&i.Nonce,
		&i.ConnectionType,
		&i.Description,
		&i.Metadata,
		&i.TransactionAt,
		&i.ConfirmedAt,
		&i.SyncedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const settingTransaction = `-- name: SettingTransaction :one
UPDATE transactions
SET
    status = 'setting',
    updated_at = NOW()
WHERE id = $1 AND status = 'confirmed'
RETURNING id, from_wallet_id, to_wallet_id, amount, currency, type, status, signature, nonce, connection_type, description, metadata, transaction_at, confirmed_at, synced_at, created_at, updated_at
`

func (q *Queries) SettingTransaction(ctx context.Context, id uuid.UUID) (Transaction, error) {
	row := q.db.QueryRow(ctx, settingTransaction, id)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.FromWalletID,
		&i.ToWalletID,
		&i.Amount,
		&i.Currency,
		&i.Type,
		&i.Status,
		&i.Signature,
		&i.Nonce,
		&i.ConnectionType,
		&i.Description,
		&i.Metadata,
		&i.TransactionAt,
		&i.ConfirmedAt,
		&i.SyncedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const settledTransaction = `-- name: SettledTransaction :one
UPDATE transactions
SET
    status = 'settled',
    synced_at = NOW(),
    updated_at = NOW()
WHERE id = $1 AND status IN ('confirmed', 'settling')
RETURNING id, from_wallet_id, to_wallet_id, amount, currency, type, status, signature, nonce, connection_type, description, metadata, transaction_at, confirmed_at, synced_at, created_at, updated_at
`

func (q *Queries) SettledTransaction(ctx context.Context, id uuid.UUID) (Transaction, error) {
	row := q.db.QueryRow(ctx, settledTransaction, id)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.FromWalletID,
		&i.ToWalletID,
		&i.Amount,
		&i.Currency,
		&i.Type,
		&i.Status,
		&i.Signature,
		&i.Nonce,
		&i.ConnectionType,
		&i.Description,
		&i.Metadata,
		&i.TransactionAt,
		&i.ConfirmedAt,
		&i.SyncedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateTransactionStatus = `-- name: UpdateTransactionStatus :one
UPDATE transactions
SET 
    status = $2,
    confirmed_at = CASE WHEN $2 = 'confirmed' THEN NOW() ELSE confirmed_at END,
    synced_at = CASE WHEN $2 = 'synced' THEN NOW() ELSE synced_at END,
    updated_at = NOW()
WHERE id = $1
RETURNING id, from_wallet_id, to_wallet_id, amount, currency, type, status, signature, nonce, connection_type, description, metadata, transaction_at, confirmed_at, synced_at, created_at, updated_at
`

type UpdateTransactionStatusParams struct {
	ID     uuid.UUID         `json:"id"`
	Status TransactionStatus `json:"status"`
}

func (q *Queries) UpdateTransactionStatus(ctx context.Context, arg UpdateTransactionStatusParams) (Transaction, error) {
	row := q.db.QueryRow(ctx, updateTransactionStatus, arg.ID, arg.Status)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.FromWalletID,
		&i.ToWalletID,
		&i.Amount,
		&i.Currency,
		&i.Type,
		&i.Status,
		&i.Signature,
		&i.Nonce,
		&i.ConnectionType,
		&i.Description,
		&i.Metadata,
		&i.TransactionAt,
		&i.ConfirmedAt,
		&i.SyncedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
