// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: utils.sql

package database

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const getSystemStats = `-- name: GetSystemStats :one
SELECT 
    COUNT(DISTINCT w.id) as total_wallets,
    COUNT(DISTINCT CASE WHEN w.is_active THEN w.id END) as active_wallets,
    COUNT(DISTINCT t.id) as total_transactions,
    COALESCE(SUM(t.amount), 0) as total_volume,
    COUNT(DISTINCT p.id) as total_peers,
    COUNT(DISTINCT CASE WHEN sl.status = 'pending' THEN sl.id END) as pending_syncs
FROM wallets w
LEFT JOIN transactions t ON (t.from_wallet_id = w.id OR t.to_wallet_id = w.id)
LEFT JOIN peers p ON p.wallet_id = w.id
LEFT JOIN sync_logs sl ON sl.wallet_id = w.id
`

type GetSystemStatsRow struct {
	TotalWallets      int64       `json:"total_wallets"`
	ActiveWallets     int64       `json:"active_wallets"`
	TotalTransactions int64       `json:"total_transactions"`
	TotalVolume       interface{} `json:"total_volume"`
	TotalPeers        int64       `json:"total_peers"`
	PendingSyncs      int64       `json:"pending_syncs"`
}

func (q *Queries) GetSystemStats(ctx context.Context) (GetSystemStatsRow, error) {
	row := q.db.QueryRow(ctx, getSystemStats)
	var i GetSystemStatsRow
	err := row.Scan(
		&i.TotalWallets,
		&i.ActiveWallets,
		&i.TotalTransactions,
		&i.TotalVolume,
		&i.TotalPeers,
		&i.PendingSyncs,
	)
	return i, err
}

const getWalletBalanceHistory = `-- name: GetWalletBalanceHistory :many
WITH balance_changes AS (
    SELECT 
        transaction_at as change_time,
        CASE 
            WHEN from_wallet_id = $1 THEN -amount
            WHEN to_wallet_id = $1 THEN amount
        END as change
    FROM transactions
    WHERE (from_wallet_id = $1 OR to_wallet_id = $1)
      AND status IN ('confirmed', 'settled')
    ORDER BY transaction_at
)
SELECT 
    change_time,
    change,
    SUM(change) OVER (ORDER BY change_time) as running_balance
FROM balance_changes
ORDER BY change_time DESC
LIMIT $2
`

type GetWalletBalanceHistoryParams struct {
	FromWalletID uuid.UUID `json:"from_wallet_id"`
	Limit        int32     `json:"limit"`
}

type GetWalletBalanceHistoryRow struct {
	ChangeTime     pgtype.Timestamptz `json:"change_time"`
	Change         interface{}        `json:"change"`
	RunningBalance int64              `json:"running_balance"`
}

func (q *Queries) GetWalletBalanceHistory(ctx context.Context, arg GetWalletBalanceHistoryParams) ([]GetWalletBalanceHistoryRow, error) {
	rows, err := q.db.Query(ctx, getWalletBalanceHistory, arg.FromWalletID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetWalletBalanceHistoryRow{}
	for rows.Next() {
		var i GetWalletBalanceHistoryRow
		if err := rows.Scan(&i.ChangeTime, &i.Change, &i.RunningBalance); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWalletDashboard = `-- name: GetWalletDashboard :one

SELECT 
    w.id,
    w.name,
    w.phone_number,
    w.balance,
    w.last_synced_at,
    COUNT(DISTINCT CASE WHEN t.from_wallet_id = w.id OR t.to_wallet_id = w.id THEN t.id END) as total_transactions,
    COUNT(DISTINCT p.id) as total_peers,
    COUNT(DISTINCT CASE WHEN sl.status = 'pending' THEN sl.id END) as pending_syncs
FROM wallets w
LEFT JOIN transactions t ON (t.from_wallet_id = w.id OR t.to_wallet_id = w.id)
LEFT JOIN peers p ON p.wallet_id = w.id AND p.deleted_at IS NULL
LEFT JOIN sync_logs sl ON sl.wallet_id = w.id
WHERE w.id = $1 AND w.deleted_at IS NULL
GROUP BY w.id
`

type GetWalletDashboardRow struct {
	ID                uuid.UUID          `json:"id"`
	Name              string             `json:"name"`
	PhoneNumber       string             `json:"phone_number"`
	Balance           pgtype.Numeric     `json:"balance"`
	LastSyncedAt      pgtype.Timestamptz `json:"last_synced_at"`
	TotalTransactions int64              `json:"total_transactions"`
	TotalPeers        int64              `json:"total_peers"`
	PendingSyncs      int64              `json:"pending_syncs"`
}

// internal/database/query/utils.sql
func (q *Queries) GetWalletDashboard(ctx context.Context, id uuid.UUID) (GetWalletDashboardRow, error) {
	row := q.db.QueryRow(ctx, getWalletDashboard, id)
	var i GetWalletDashboardRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.PhoneNumber,
		&i.Balance,
		&i.LastSyncedAt,
		&i.TotalTransactions,
		&i.TotalPeers,
		&i.PendingSyncs,
	)
	return i, err
}

const searchTransactions = `-- name: SearchTransactions :many
SELECT 
    t.id, t.from_wallet_id, t.to_wallet_id, t.amount, t.currency, t.type, t.status, t.signature, t.nonce, t.connection_type, t.description, t.metadata, t.transaction_at, t.confirmed_at, t.synced_at, t.created_at, t.updated_at,
    w_from.name as from_wallet_name,
    w_from.phone_number as from_wallet_phone,
    w_to.name as to_wallet_name,
    w_to.phone_number as to_wallet_phone
FROM transactions t
JOIN wallets w_from ON t.from_wallet_id = w_from.id
JOIN wallets w_to ON t.to_wallet_id = w_to.id
WHERE (
    w_from.name ILIKE '%' || $1 || '%'
    OR w_to.name ILIKE '%' || $1 || '%'
    OR w_from.phone_number LIKE '%' || $1 || '%'
    OR w_to.phone_number LIKE '%' || $1 || '%'
    OR t.metadata::text ILIKE '%' || $1 || '%'
)
ORDER BY t.transaction_at DESC
LIMIT $2 OFFSET $3
`

type SearchTransactionsParams struct {
	Column1 *string `json:"column_1"`
	Limit   int32   `json:"limit"`
	Offset  int32   `json:"offset"`
}

type SearchTransactionsRow struct {
	ID              uuid.UUID          `json:"id"`
	FromWalletID    uuid.UUID          `json:"from_wallet_id"`
	ToWalletID      uuid.UUID          `json:"to_wallet_id"`
	Amount          pgtype.Numeric     `json:"amount"`
	Currency        string             `json:"currency"`
	Type            TransactionType    `json:"type"`
	Status          TransactionStatus  `json:"status"`
	Signature       string             `json:"signature"`
	Nonce           int64              `json:"nonce"`
	ConnectionType  NullConnectionType `json:"connection_type"`
	Description     *string            `json:"description"`
	Metadata        []byte             `json:"metadata"`
	TransactionAt   pgtype.Timestamptz `json:"transaction_at"`
	ConfirmedAt     pgtype.Timestamptz `json:"confirmed_at"`
	SyncedAt        pgtype.Timestamptz `json:"synced_at"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `json:"updated_at"`
	FromWalletName  string             `json:"from_wallet_name"`
	FromWalletPhone string             `json:"from_wallet_phone"`
	ToWalletName    string             `json:"to_wallet_name"`
	ToWalletPhone   string             `json:"to_wallet_phone"`
}

func (q *Queries) SearchTransactions(ctx context.Context, arg SearchTransactionsParams) ([]SearchTransactionsRow, error) {
	rows, err := q.db.Query(ctx, searchTransactions, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchTransactionsRow{}
	for rows.Next() {
		var i SearchTransactionsRow
		if err := rows.Scan(
			&i.ID,
			&i.FromWalletID,
			&i.ToWalletID,
			&i.Amount,
			&i.Currency,
			&i.Type,
			&i.Status,
			&i.Signature,
			&i.Nonce,
			&i.ConnectionType,
			&i.Description,
			&i.Metadata,
			&i.TransactionAt,
			&i.ConfirmedAt,
			&i.SyncedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.FromWalletName,
			&i.FromWalletPhone,
			&i.ToWalletName,
			&i.ToWalletPhone,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
