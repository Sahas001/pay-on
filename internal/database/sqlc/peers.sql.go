// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: peers.sql

package database

import (
	"context"
	"net"
	"net/netip"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const autoTrustFrequentPeers = `-- name: AutoTrustFrequentPeers :exec
UPDATE peers
SET is_trusted = TRUE, updated_at = NOW()
WHERE transaction_count >= $1
  AND is_trusted = FALSE
  AND last_seen_at > NOW() - INTERVAL '30 days'
  AND deleted_at IS NULL
`

func (q *Queries) AutoTrustFrequentPeers(ctx context.Context, transactionCount *int32) error {
	_, err := q.db.Exec(ctx, autoTrustFrequentPeers, transactionCount)
	return err
}

const countPeersByWallet = `-- name: CountPeersByWallet :one
SELECT COUNT(*) FROM peers
WHERE wallet_id = $1 AND deleted_at IS NULL
`

func (q *Queries) CountPeersByWallet(ctx context.Context, walletID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countPeersByWallet, walletID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countTrustedPeers = `-- name: CountTrustedPeers :one
SELECT COUNT(*) FROM peers
WHERE wallet_id = $1 AND is_trusted = TRUE AND deleted_at IS NULL
`

func (q *Queries) CountTrustedPeers(ctx context.Context, walletID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countTrustedPeers, walletID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createPeer = `-- name: CreatePeer :one

INSERT INTO peers (
    wallet_id,
    peer_wallet_id,
    name,
    public_key,
    ip_address,
    bt_address,
    connection_type,
    is_trusted
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
) RETURNING id, wallet_id, peer_wallet_id, name, public_key, ip_address, bt_address, connection_type, is_trusted, transaction_count, last_seen_at, first_seen_at, created_at, updated_at, deleted_at
`

type CreatePeerParams struct {
	WalletID       uuid.UUID        `json:"wallet_id"`
	PeerWalletID   uuid.UUID        `json:"peer_wallet_id"`
	Name           *string          `json:"name"`
	PublicKey      string           `json:"public_key"`
	IpAddress      *netip.Addr      `json:"ip_address"`
	BtAddress      net.HardwareAddr `json:"bt_address"`
	ConnectionType ConnectionType   `json:"connection_type"`
	IsTrusted      *bool            `json:"is_trusted"`
}

// internal/database/query/peers.sql
func (q *Queries) CreatePeer(ctx context.Context, arg CreatePeerParams) (Peer, error) {
	row := q.db.QueryRow(ctx, createPeer,
		arg.WalletID,
		arg.PeerWalletID,
		arg.Name,
		arg.PublicKey,
		arg.IpAddress,
		arg.BtAddress,
		arg.ConnectionType,
		arg.IsTrusted,
	)
	var i Peer
	err := row.Scan(
		&i.ID,
		&i.WalletID,
		&i.PeerWalletID,
		&i.Name,
		&i.PublicKey,
		&i.IpAddress,
		&i.BtAddress,
		&i.ConnectionType,
		&i.IsTrusted,
		&i.TransactionCount,
		&i.LastSeenAt,
		&i.FirstSeenAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const deletePeer = `-- name: DeletePeer :exec
UPDATE peers
SET deleted_at = NOW(), updated_at = NOW()
WHERE id = $1
`

func (q *Queries) DeletePeer(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deletePeer, id)
	return err
}

const getPeerByID = `-- name: GetPeerByID :one
SELECT id, wallet_id, peer_wallet_id, name, public_key, ip_address, bt_address, connection_type, is_trusted, transaction_count, last_seen_at, first_seen_at, created_at, updated_at, deleted_at FROM peers
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetPeerByID(ctx context.Context, id uuid.UUID) (Peer, error) {
	row := q.db.QueryRow(ctx, getPeerByID, id)
	var i Peer
	err := row.Scan(
		&i.ID,
		&i.WalletID,
		&i.PeerWalletID,
		&i.Name,
		&i.PublicKey,
		&i.IpAddress,
		&i.BtAddress,
		&i.ConnectionType,
		&i.IsTrusted,
		&i.TransactionCount,
		&i.LastSeenAt,
		&i.FirstSeenAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getPeerByWalletAndPeerID = `-- name: GetPeerByWalletAndPeerID :one
SELECT id, wallet_id, peer_wallet_id, name, public_key, ip_address, bt_address, connection_type, is_trusted, transaction_count, last_seen_at, first_seen_at, created_at, updated_at, deleted_at FROM peers
WHERE wallet_id = $1 AND peer_wallet_id = $2 AND deleted_at IS NULL
`

type GetPeerByWalletAndPeerIDParams struct {
	WalletID     uuid.UUID `json:"wallet_id"`
	PeerWalletID uuid.UUID `json:"peer_wallet_id"`
}

func (q *Queries) GetPeerByWalletAndPeerID(ctx context.Context, arg GetPeerByWalletAndPeerIDParams) (Peer, error) {
	row := q.db.QueryRow(ctx, getPeerByWalletAndPeerID, arg.WalletID, arg.PeerWalletID)
	var i Peer
	err := row.Scan(
		&i.ID,
		&i.WalletID,
		&i.PeerWalletID,
		&i.Name,
		&i.PublicKey,
		&i.IpAddress,
		&i.BtAddress,
		&i.ConnectionType,
		&i.IsTrusted,
		&i.TransactionCount,
		&i.LastSeenAt,
		&i.FirstSeenAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getStalePeers = `-- name: GetStalePeers :many
SELECT id, wallet_id, peer_wallet_id, name, public_key, ip_address, bt_address, connection_type, is_trusted, transaction_count, last_seen_at, first_seen_at, created_at, updated_at, deleted_at FROM peers
WHERE last_seen_at < NOW() - INTERVAL '90 days'
  AND deleted_at IS NULL
ORDER BY last_seen_at ASC
LIMIT $1
`

func (q *Queries) GetStalePeers(ctx context.Context, limit int32) ([]Peer, error) {
	rows, err := q.db.Query(ctx, getStalePeers, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Peer{}
	for rows.Next() {
		var i Peer
		if err := rows.Scan(
			&i.ID,
			&i.WalletID,
			&i.PeerWalletID,
			&i.Name,
			&i.PublicKey,
			&i.IpAddress,
			&i.BtAddress,
			&i.ConnectionType,
			&i.IsTrusted,
			&i.TransactionCount,
			&i.LastSeenAt,
			&i.FirstSeenAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopPeersByTransactionCount = `-- name: GetTopPeersByTransactionCount :many
SELECT id, wallet_id, peer_wallet_id, name, public_key, ip_address, bt_address, connection_type, is_trusted, transaction_count, last_seen_at, first_seen_at, created_at, updated_at, deleted_at FROM peers
WHERE wallet_id = $1 AND deleted_at IS NULL
ORDER BY transaction_count DESC
LIMIT $2
`

type GetTopPeersByTransactionCountParams struct {
	WalletID uuid.UUID `json:"wallet_id"`
	Limit    int32     `json:"limit"`
}

func (q *Queries) GetTopPeersByTransactionCount(ctx context.Context, arg GetTopPeersByTransactionCountParams) ([]Peer, error) {
	rows, err := q.db.Query(ctx, getTopPeersByTransactionCount, arg.WalletID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Peer{}
	for rows.Next() {
		var i Peer
		if err := rows.Scan(
			&i.ID,
			&i.WalletID,
			&i.PeerWalletID,
			&i.Name,
			&i.PublicKey,
			&i.IpAddress,
			&i.BtAddress,
			&i.ConnectionType,
			&i.IsTrusted,
			&i.TransactionCount,
			&i.LastSeenAt,
			&i.FirstSeenAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopPeersByVolume = `-- name: GetTopPeersByVolume :many
SELECT 
    p.id, p.wallet_id, p.peer_wallet_id, p.name, p.public_key, p.ip_address, p.bt_address, p.connection_type, p.is_trusted, p.transaction_count, p.last_seen_at, p.first_seen_at, p.created_at, p.updated_at, p.deleted_at,
    COALESCE(SUM(t.amount), 0) as total_volume
FROM peers p
LEFT JOIN transactions t ON (
    (t.from_wallet_id = p.wallet_id AND t.to_wallet_id = p.peer_wallet_id)
    OR
    (t.to_wallet_id = p.wallet_id AND t.from_wallet_id = p.peer_wallet_id)
)
WHERE p.wallet_id = $1 AND p.deleted_at IS NULL
GROUP BY p.id
ORDER BY total_volume DESC
LIMIT $2
`

type GetTopPeersByVolumeParams struct {
	WalletID uuid.UUID `json:"wallet_id"`
	Limit    int32     `json:"limit"`
}

type GetTopPeersByVolumeRow struct {
	ID               uuid.UUID          `json:"id"`
	WalletID         uuid.UUID          `json:"wallet_id"`
	PeerWalletID     uuid.UUID          `json:"peer_wallet_id"`
	Name             *string            `json:"name"`
	PublicKey        string             `json:"public_key"`
	IpAddress        *netip.Addr        `json:"ip_address"`
	BtAddress        net.HardwareAddr   `json:"bt_address"`
	ConnectionType   ConnectionType     `json:"connection_type"`
	IsTrusted        *bool              `json:"is_trusted"`
	TransactionCount *int32             `json:"transaction_count"`
	LastSeenAt       pgtype.Timestamptz `json:"last_seen_at"`
	FirstSeenAt      pgtype.Timestamptz `json:"first_seen_at"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
	UpdatedAt        pgtype.Timestamptz `json:"updated_at"`
	DeletedAt        pgtype.Timestamptz `json:"deleted_at"`
	TotalVolume      interface{}        `json:"total_volume"`
}

func (q *Queries) GetTopPeersByVolume(ctx context.Context, arg GetTopPeersByVolumeParams) ([]GetTopPeersByVolumeRow, error) {
	rows, err := q.db.Query(ctx, getTopPeersByVolume, arg.WalletID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTopPeersByVolumeRow{}
	for rows.Next() {
		var i GetTopPeersByVolumeRow
		if err := rows.Scan(
			&i.ID,
			&i.WalletID,
			&i.PeerWalletID,
			&i.Name,
			&i.PublicKey,
			&i.IpAddress,
			&i.BtAddress,
			&i.ConnectionType,
			&i.IsTrusted,
			&i.TransactionCount,
			&i.LastSeenAt,
			&i.FirstSeenAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TotalVolume,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const hardDeletePeer = `-- name: HardDeletePeer :exec
DELETE FROM peers
WHERE id = $1
`

func (q *Queries) HardDeletePeer(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, hardDeletePeer, id)
	return err
}

const incrementPeerTransactionCount = `-- name: IncrementPeerTransactionCount :exec
UPDATE peers
SET 
    transaction_count = transaction_count + 1,
    last_seen_at = NOW(),
    updated_at = NOW()
WHERE wallet_id = $1 AND peer_wallet_id = $2
`

type IncrementPeerTransactionCountParams struct {
	WalletID     uuid.UUID `json:"wallet_id"`
	PeerWalletID uuid.UUID `json:"peer_wallet_id"`
}

func (q *Queries) IncrementPeerTransactionCount(ctx context.Context, arg IncrementPeerTransactionCountParams) error {
	_, err := q.db.Exec(ctx, incrementPeerTransactionCount, arg.WalletID, arg.PeerWalletID)
	return err
}

const listPeersByConnectionType = `-- name: ListPeersByConnectionType :many
SELECT id, wallet_id, peer_wallet_id, name, public_key, ip_address, bt_address, connection_type, is_trusted, transaction_count, last_seen_at, first_seen_at, created_at, updated_at, deleted_at FROM peers
WHERE wallet_id = $1 AND connection_type = $2 AND deleted_at IS NULL
ORDER BY last_seen_at DESC
LIMIT $3
`

type ListPeersByConnectionTypeParams struct {
	WalletID       uuid.UUID      `json:"wallet_id"`
	ConnectionType ConnectionType `json:"connection_type"`
	Limit          int32          `json:"limit"`
}

func (q *Queries) ListPeersByConnectionType(ctx context.Context, arg ListPeersByConnectionTypeParams) ([]Peer, error) {
	rows, err := q.db.Query(ctx, listPeersByConnectionType, arg.WalletID, arg.ConnectionType, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Peer{}
	for rows.Next() {
		var i Peer
		if err := rows.Scan(
			&i.ID,
			&i.WalletID,
			&i.PeerWalletID,
			&i.Name,
			&i.PublicKey,
			&i.IpAddress,
			&i.BtAddress,
			&i.ConnectionType,
			&i.IsTrusted,
			&i.TransactionCount,
			&i.LastSeenAt,
			&i.FirstSeenAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPeersByWallet = `-- name: ListPeersByWallet :many
SELECT id, wallet_id, peer_wallet_id, name, public_key, ip_address, bt_address, connection_type, is_trusted, transaction_count, last_seen_at, first_seen_at, created_at, updated_at, deleted_at FROM peers
WHERE wallet_id = $1 AND deleted_at IS NULL
ORDER BY last_seen_at DESC
LIMIT $2 OFFSET $3
`

type ListPeersByWalletParams struct {
	WalletID uuid.UUID `json:"wallet_id"`
	Limit    int32     `json:"limit"`
	Offset   int32     `json:"offset"`
}

func (q *Queries) ListPeersByWallet(ctx context.Context, arg ListPeersByWalletParams) ([]Peer, error) {
	rows, err := q.db.Query(ctx, listPeersByWallet, arg.WalletID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Peer{}
	for rows.Next() {
		var i Peer
		if err := rows.Scan(
			&i.ID,
			&i.WalletID,
			&i.PeerWalletID,
			&i.Name,
			&i.PublicKey,
			&i.IpAddress,
			&i.BtAddress,
			&i.ConnectionType,
			&i.IsTrusted,
			&i.TransactionCount,
			&i.LastSeenAt,
			&i.FirstSeenAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRecentPeers = `-- name: ListRecentPeers :many
SELECT id, wallet_id, peer_wallet_id, name, public_key, ip_address, bt_address, connection_type, is_trusted, transaction_count, last_seen_at, first_seen_at, created_at, updated_at, deleted_at FROM peers
WHERE wallet_id = $1 
  AND last_seen_at >= NOW() - INTERVAL '7 days'
  AND deleted_at IS NULL
ORDER BY last_seen_at DESC
LIMIT $2
`

type ListRecentPeersParams struct {
	WalletID uuid.UUID `json:"wallet_id"`
	Limit    int32     `json:"limit"`
}

func (q *Queries) ListRecentPeers(ctx context.Context, arg ListRecentPeersParams) ([]Peer, error) {
	rows, err := q.db.Query(ctx, listRecentPeers, arg.WalletID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Peer{}
	for rows.Next() {
		var i Peer
		if err := rows.Scan(
			&i.ID,
			&i.WalletID,
			&i.PeerWalletID,
			&i.Name,
			&i.PublicKey,
			&i.IpAddress,
			&i.BtAddress,
			&i.ConnectionType,
			&i.IsTrusted,
			&i.TransactionCount,
			&i.LastSeenAt,
			&i.FirstSeenAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTrustedPeers = `-- name: ListTrustedPeers :many
SELECT id, wallet_id, peer_wallet_id, name, public_key, ip_address, bt_address, connection_type, is_trusted, transaction_count, last_seen_at, first_seen_at, created_at, updated_at, deleted_at FROM peers
WHERE wallet_id = $1 AND is_trusted = TRUE AND deleted_at IS NULL
ORDER BY last_seen_at DESC
`

func (q *Queries) ListTrustedPeers(ctx context.Context, walletID uuid.UUID) ([]Peer, error) {
	rows, err := q.db.Query(ctx, listTrustedPeers, walletID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Peer{}
	for rows.Next() {
		var i Peer
		if err := rows.Scan(
			&i.ID,
			&i.WalletID,
			&i.PeerWalletID,
			&i.Name,
			&i.PublicKey,
			&i.IpAddress,
			&i.BtAddress,
			&i.ConnectionType,
			&i.IsTrusted,
			&i.TransactionCount,
			&i.LastSeenAt,
			&i.FirstSeenAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setPeerTrusted = `-- name: SetPeerTrusted :exec
UPDATE peers
SET is_trusted = $2, updated_at = NOW()
WHERE id = $1
`

type SetPeerTrustedParams struct {
	ID        uuid.UUID `json:"id"`
	IsTrusted *bool     `json:"is_trusted"`
}

func (q *Queries) SetPeerTrusted(ctx context.Context, arg SetPeerTrustedParams) error {
	_, err := q.db.Exec(ctx, setPeerTrusted, arg.ID, arg.IsTrusted)
	return err
}

const updatePeerInfo = `-- name: UpdatePeerInfo :one
UPDATE peers
SET 
    name = COALESCE($3, name),
    ip_address = COALESCE($4, ip_address),
    bt_address = COALESCE($5, bt_address),
    connection_type = COALESCE($6, connection_type),
    last_seen_at = NOW(),
    updated_at = NOW()
WHERE wallet_id = $1 AND peer_wallet_id = $2
RETURNING id, wallet_id, peer_wallet_id, name, public_key, ip_address, bt_address, connection_type, is_trusted, transaction_count, last_seen_at, first_seen_at, created_at, updated_at, deleted_at
`

type UpdatePeerInfoParams struct {
	WalletID       uuid.UUID          `json:"wallet_id"`
	PeerWalletID   uuid.UUID          `json:"peer_wallet_id"`
	Name           *string            `json:"name"`
	IpAddress      *netip.Addr        `json:"ip_address"`
	BtAddress      net.HardwareAddr   `json:"bt_address"`
	ConnectionType NullConnectionType `json:"connection_type"`
}

func (q *Queries) UpdatePeerInfo(ctx context.Context, arg UpdatePeerInfoParams) (Peer, error) {
	row := q.db.QueryRow(ctx, updatePeerInfo,
		arg.WalletID,
		arg.PeerWalletID,
		arg.Name,
		arg.IpAddress,
		arg.BtAddress,
		arg.ConnectionType,
	)
	var i Peer
	err := row.Scan(
		&i.ID,
		&i.WalletID,
		&i.PeerWalletID,
		&i.Name,
		&i.PublicKey,
		&i.IpAddress,
		&i.BtAddress,
		&i.ConnectionType,
		&i.IsTrusted,
		&i.TransactionCount,
		&i.LastSeenAt,
		&i.FirstSeenAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const updatePeerLastSeen = `-- name: UpdatePeerLastSeen :exec
UPDATE peers
SET last_seen_at = NOW(), updated_at = NOW()
WHERE id = $1
`

func (q *Queries) UpdatePeerLastSeen(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, updatePeerLastSeen, id)
	return err
}

const upsertPeer = `-- name: UpsertPeer :one
INSERT INTO peers (
    wallet_id,
    peer_wallet_id,
    name,
    public_key,
    ip_address,
    bt_address,
    connection_type,
    is_trusted,
    last_seen_at
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, NOW()
)
ON CONFLICT (wallet_id, peer_wallet_id)
DO UPDATE SET
    name = EXCLUDED.name,
    ip_address = EXCLUDED.ip_address,
    bt_address = EXCLUDED.bt_address,
    connection_type = EXCLUDED.connection_type,
    last_seen_at = NOW(),
    updated_at = NOW()
RETURNING id, wallet_id, peer_wallet_id, name, public_key, ip_address, bt_address, connection_type, is_trusted, transaction_count, last_seen_at, first_seen_at, created_at, updated_at, deleted_at
`

type UpsertPeerParams struct {
	WalletID       uuid.UUID        `json:"wallet_id"`
	PeerWalletID   uuid.UUID        `json:"peer_wallet_id"`
	Name           *string          `json:"name"`
	PublicKey      string           `json:"public_key"`
	IpAddress      *netip.Addr      `json:"ip_address"`
	BtAddress      net.HardwareAddr `json:"bt_address"`
	ConnectionType ConnectionType   `json:"connection_type"`
	IsTrusted      *bool            `json:"is_trusted"`
}

func (q *Queries) UpsertPeer(ctx context.Context, arg UpsertPeerParams) (Peer, error) {
	row := q.db.QueryRow(ctx, upsertPeer,
		arg.WalletID,
		arg.PeerWalletID,
		arg.Name,
		arg.PublicKey,
		arg.IpAddress,
		arg.BtAddress,
		arg.ConnectionType,
		arg.IsTrusted,
	)
	var i Peer
	err := row.Scan(
		&i.ID,
		&i.WalletID,
		&i.PeerWalletID,
		&i.Name,
		&i.PublicKey,
		&i.IpAddress,
		&i.BtAddress,
		&i.ConnectionType,
		&i.IsTrusted,
		&i.TransactionCount,
		&i.LastSeenAt,
		&i.FirstSeenAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}
