// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: sync_logs.sql

package database

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countSyncLogsByStatus = `-- name: CountSyncLogsByStatus :one
SELECT COUNT(*) FROM sync_logs
WHERE status = $1
`

func (q *Queries) CountSyncLogsByStatus(ctx context.Context, status SyncStatus) (int64, error) {
	row := q.db.QueryRow(ctx, countSyncLogsByStatus, status)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createSyncLog = `-- name: CreateSyncLog :one

INSERT INTO sync_logs (
    transaction_id,
    wallet_id,
    status
) VALUES (
    $1, $2, $3
) RETURNING id, transaction_id, wallet_id, status, attempt_count, last_attempt_at, error_message, conflict_data, resolved_at, created_at, updated_at
`

type CreateSyncLogParams struct {
	TransactionID uuid.UUID  `json:"transaction_id"`
	WalletID      uuid.UUID  `json:"wallet_id"`
	Status        SyncStatus `json:"status"`
}

// internal/database/query/sync_logs.sql
func (q *Queries) CreateSyncLog(ctx context.Context, arg CreateSyncLogParams) (SyncLog, error) {
	row := q.db.QueryRow(ctx, createSyncLog, arg.TransactionID, arg.WalletID, arg.Status)
	var i SyncLog
	err := row.Scan(
		&i.ID,
		&i.TransactionID,
		&i.WalletID,
		&i.Status,
		&i.AttemptCount,
		&i.LastAttemptAt,
		&i.ErrorMessage,
		&i.ConflictData,
		&i.ResolvedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteOldSyncLogs = `-- name: DeleteOldSyncLogs :exec
DELETE FROM sync_logs
WHERE status = 'settled'
  AND updated_at < NOW() - ($1 || ' days')::INTERVAL
`

func (q *Queries) DeleteOldSyncLogs(ctx context.Context, dollar_1 *string) error {
	_, err := q.db.Exec(ctx, deleteOldSyncLogs, dollar_1)
	return err
}

const getSyncLogByID = `-- name: GetSyncLogByID :one
SELECT id, transaction_id, wallet_id, status, attempt_count, last_attempt_at, error_message, conflict_data, resolved_at, created_at, updated_at FROM sync_logs
WHERE id = $1
`

func (q *Queries) GetSyncLogByID(ctx context.Context, id uuid.UUID) (SyncLog, error) {
	row := q.db.QueryRow(ctx, getSyncLogByID, id)
	var i SyncLog
	err := row.Scan(
		&i.ID,
		&i.TransactionID,
		&i.WalletID,
		&i.Status,
		&i.AttemptCount,
		&i.LastAttemptAt,
		&i.ErrorMessage,
		&i.ConflictData,
		&i.ResolvedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getSyncLogsByTransaction = `-- name: GetSyncLogsByTransaction :many
SELECT id, transaction_id, wallet_id, status, attempt_count, last_attempt_at, error_message, conflict_data, resolved_at, created_at, updated_at FROM sync_logs
WHERE transaction_id = $1
ORDER BY created_at DESC
`

func (q *Queries) GetSyncLogsByTransaction(ctx context.Context, transactionID uuid.UUID) ([]SyncLog, error) {
	rows, err := q.db.Query(ctx, getSyncLogsByTransaction, transactionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SyncLog{}
	for rows.Next() {
		var i SyncLog
		if err := rows.Scan(
			&i.ID,
			&i.TransactionID,
			&i.WalletID,
			&i.Status,
			&i.AttemptCount,
			&i.LastAttemptAt,
			&i.ErrorMessage,
			&i.ConflictData,
			&i.ResolvedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSyncLogsByWallet = `-- name: GetSyncLogsByWallet :many
SELECT id, transaction_id, wallet_id, status, attempt_count, last_attempt_at, error_message, conflict_data, resolved_at, created_at, updated_at FROM sync_logs
WHERE wallet_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetSyncLogsByWalletParams struct {
	WalletID uuid.UUID `json:"wallet_id"`
	Limit    int32     `json:"limit"`
	Offset   int32     `json:"offset"`
}

func (q *Queries) GetSyncLogsByWallet(ctx context.Context, arg GetSyncLogsByWalletParams) ([]SyncLog, error) {
	rows, err := q.db.Query(ctx, getSyncLogsByWallet, arg.WalletID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SyncLog{}
	for rows.Next() {
		var i SyncLog
		if err := rows.Scan(
			&i.ID,
			&i.TransactionID,
			&i.WalletID,
			&i.Status,
			&i.AttemptCount,
			&i.LastAttemptAt,
			&i.ErrorMessage,
			&i.ConflictData,
			&i.ResolvedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSyncStats = `-- name: GetSyncStats :one
SELECT 
    COUNT(*) FILTER (WHERE status = 'pending') as pending_count,
    COUNT(*) FILTER (WHERE status = 'settled') as synced_count,
    COUNT(*) FILTER (WHERE status = 'failed') as failed_count,
    COUNT(*) FILTER (WHERE status = 'conflict') as conflict_count,
    AVG(attempt_count) as avg_attempts
FROM sync_logs
WHERE wallet_id = $1
`

type GetSyncStatsRow struct {
	PendingCount  int64   `json:"pending_count"`
	SyncedCount   int64   `json:"synced_count"`
	FailedCount   int64   `json:"failed_count"`
	ConflictCount int64   `json:"conflict_count"`
	AvgAttempts   float64 `json:"avg_attempts"`
}

func (q *Queries) GetSyncStats(ctx context.Context, walletID uuid.UUID) (GetSyncStatsRow, error) {
	row := q.db.QueryRow(ctx, getSyncStats, walletID)
	var i GetSyncStatsRow
	err := row.Scan(
		&i.PendingCount,
		&i.SyncedCount,
		&i.FailedCount,
		&i.ConflictCount,
		&i.AvgAttempts,
	)
	return i, err
}

const getSyncsNeedingRetry = `-- name: GetSyncsNeedingRetry :many
SELECT id, transaction_id, wallet_id, status, attempt_count, last_attempt_at, error_message, conflict_data, resolved_at, created_at, updated_at FROM sync_logs
WHERE status = 'failed'
  AND attempt_count < $1
  AND (last_attempt_at IS NULL OR last_attempt_at < NOW() - INTERVAL '5 minutes')
ORDER BY attempt_count ASC, created_at ASC
LIMIT $2
`

type GetSyncsNeedingRetryParams struct {
	AttemptCount *int32 `json:"attempt_count"`
	Limit        int32  `json:"limit"`
}

func (q *Queries) GetSyncsNeedingRetry(ctx context.Context, arg GetSyncsNeedingRetryParams) ([]SyncLog, error) {
	rows, err := q.db.Query(ctx, getSyncsNeedingRetry, arg.AttemptCount, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SyncLog{}
	for rows.Next() {
		var i SyncLog
		if err := rows.Scan(
			&i.ID,
			&i.TransactionID,
			&i.WalletID,
			&i.Status,
			&i.AttemptCount,
			&i.LastAttemptAt,
			&i.ErrorMessage,
			&i.ConflictData,
			&i.ResolvedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAllPendingSyncs = `-- name: ListAllPendingSyncs :many
SELECT id, transaction_id, wallet_id, status, attempt_count, last_attempt_at, error_message, conflict_data, resolved_at, created_at, updated_at FROM sync_logs
WHERE status = 'pending'
ORDER BY created_at ASC
LIMIT $1 OFFSET $2
`

type ListAllPendingSyncsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListAllPendingSyncs(ctx context.Context, arg ListAllPendingSyncsParams) ([]SyncLog, error) {
	rows, err := q.db.Query(ctx, listAllPendingSyncs, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SyncLog{}
	for rows.Next() {
		var i SyncLog
		if err := rows.Scan(
			&i.ID,
			&i.TransactionID,
			&i.WalletID,
			&i.Status,
			&i.AttemptCount,
			&i.LastAttemptAt,
			&i.ErrorMessage,
			&i.ConflictData,
			&i.ResolvedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listConflictedSyncs = `-- name: ListConflictedSyncs :many
SELECT id, transaction_id, wallet_id, status, attempt_count, last_attempt_at, error_message, conflict_data, resolved_at, created_at, updated_at FROM sync_logs
WHERE status = 'conflict'
  AND wallet_id = $1
ORDER BY created_at DESC
LIMIT $2
`

type ListConflictedSyncsParams struct {
	WalletID uuid.UUID `json:"wallet_id"`
	Limit    int32     `json:"limit"`
}

func (q *Queries) ListConflictedSyncs(ctx context.Context, arg ListConflictedSyncsParams) ([]SyncLog, error) {
	rows, err := q.db.Query(ctx, listConflictedSyncs, arg.WalletID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SyncLog{}
	for rows.Next() {
		var i SyncLog
		if err := rows.Scan(
			&i.ID,
			&i.TransactionID,
			&i.WalletID,
			&i.Status,
			&i.AttemptCount,
			&i.LastAttemptAt,
			&i.ErrorMessage,
			&i.ConflictData,
			&i.ResolvedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFailedSyncs = `-- name: ListFailedSyncs :many
SELECT id, transaction_id, wallet_id, status, attempt_count, last_attempt_at, error_message, conflict_data, resolved_at, created_at, updated_at FROM sync_logs
WHERE status = 'failed'
  AND wallet_id = $1
ORDER BY last_attempt_at DESC
LIMIT $2
`

type ListFailedSyncsParams struct {
	WalletID uuid.UUID `json:"wallet_id"`
	Limit    int32     `json:"limit"`
}

func (q *Queries) ListFailedSyncs(ctx context.Context, arg ListFailedSyncsParams) ([]SyncLog, error) {
	rows, err := q.db.Query(ctx, listFailedSyncs, arg.WalletID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SyncLog{}
	for rows.Next() {
		var i SyncLog
		if err := rows.Scan(
			&i.ID,
			&i.TransactionID,
			&i.WalletID,
			&i.Status,
			&i.AttemptCount,
			&i.LastAttemptAt,
			&i.ErrorMessage,
			&i.ConflictData,
			&i.ResolvedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPendingSyncs = `-- name: ListPendingSyncs :many
SELECT 
    sl.id, sl.transaction_id, sl.wallet_id, sl.status, sl.attempt_count, sl.last_attempt_at, sl.error_message, sl.conflict_data, sl.resolved_at, sl.created_at, sl.updated_at,
    t.amount,
    t.type as transaction_type,
    t.created_at as transaction_created_at
FROM sync_logs sl
JOIN transactions t ON sl.transaction_id = t.id
WHERE sl.status = 'pending'
  AND sl.wallet_id = $1
ORDER BY sl.created_at ASC
LIMIT $2
`

type ListPendingSyncsParams struct {
	WalletID uuid.UUID `json:"wallet_id"`
	Limit    int32     `json:"limit"`
}

type ListPendingSyncsRow struct {
	ID                   uuid.UUID          `json:"id"`
	TransactionID        uuid.UUID          `json:"transaction_id"`
	WalletID             uuid.UUID          `json:"wallet_id"`
	Status               SyncStatus         `json:"status"`
	AttemptCount         *int32             `json:"attempt_count"`
	LastAttemptAt        pgtype.Timestamptz `json:"last_attempt_at"`
	ErrorMessage         *string            `json:"error_message"`
	ConflictData         []byte             `json:"conflict_data"`
	ResolvedAt           pgtype.Timestamptz `json:"resolved_at"`
	CreatedAt            pgtype.Timestamptz `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz `json:"updated_at"`
	Amount               pgtype.Numeric     `json:"amount"`
	TransactionType      TransactionType    `json:"transaction_type"`
	TransactionCreatedAt pgtype.Timestamptz `json:"transaction_created_at"`
}

func (q *Queries) ListPendingSyncs(ctx context.Context, arg ListPendingSyncsParams) ([]ListPendingSyncsRow, error) {
	rows, err := q.db.Query(ctx, listPendingSyncs, arg.WalletID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListPendingSyncsRow{}
	for rows.Next() {
		var i ListPendingSyncsRow
		if err := rows.Scan(
			&i.ID,
			&i.TransactionID,
			&i.WalletID,
			&i.Status,
			&i.AttemptCount,
			&i.LastAttemptAt,
			&i.ErrorMessage,
			&i.ConflictData,
			&i.ResolvedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Amount,
			&i.TransactionType,
			&i.TransactionCreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markSettleConflict = `-- name: MarkSettleConflict :one
UPDATE sync_logs
SET 
    status = 'conflict',
    last_attempt_at = NOW(),
    attempt_count = attempt_count + 1,
    conflict_data = $2,
    updated_at = NOW()
WHERE id = $1
RETURNING id, transaction_id, wallet_id, status, attempt_count, last_attempt_at, error_message, conflict_data, resolved_at, created_at, updated_at
`

type MarkSettleConflictParams struct {
	ID           uuid.UUID `json:"id"`
	ConflictData []byte    `json:"conflict_data"`
}

func (q *Queries) MarkSettleConflict(ctx context.Context, arg MarkSettleConflictParams) (SyncLog, error) {
	row := q.db.QueryRow(ctx, markSettleConflict, arg.ID, arg.ConflictData)
	var i SyncLog
	err := row.Scan(
		&i.ID,
		&i.TransactionID,
		&i.WalletID,
		&i.Status,
		&i.AttemptCount,
		&i.LastAttemptAt,
		&i.ErrorMessage,
		&i.ConflictData,
		&i.ResolvedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const markSettleFailed = `-- name: MarkSettleFailed :one
UPDATE sync_logs
SET 
    status = 'failed',
    last_attempt_at = NOW(),
    attempt_count = attempt_count + 1,
    error_message = $2,
    updated_at = NOW()
WHERE id = $1
RETURNING id, transaction_id, wallet_id, status, attempt_count, last_attempt_at, error_message, conflict_data, resolved_at, created_at, updated_at
`

type MarkSettleFailedParams struct {
	ID           uuid.UUID `json:"id"`
	ErrorMessage *string   `json:"error_message"`
}

func (q *Queries) MarkSettleFailed(ctx context.Context, arg MarkSettleFailedParams) (SyncLog, error) {
	row := q.db.QueryRow(ctx, markSettleFailed, arg.ID, arg.ErrorMessage)
	var i SyncLog
	err := row.Scan(
		&i.ID,
		&i.TransactionID,
		&i.WalletID,
		&i.Status,
		&i.AttemptCount,
		&i.LastAttemptAt,
		&i.ErrorMessage,
		&i.ConflictData,
		&i.ResolvedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const markSettleSuccessful = `-- name: MarkSettleSuccessful :one
UPDATE sync_logs
SET 
    status = 'settled',
    last_attempt_at = NOW(),
    updated_at = NOW()
WHERE id = $1
RETURNING id, transaction_id, wallet_id, status, attempt_count, last_attempt_at, error_message, conflict_data, resolved_at, created_at, updated_at
`

func (q *Queries) MarkSettleSuccessful(ctx context.Context, id uuid.UUID) (SyncLog, error) {
	row := q.db.QueryRow(ctx, markSettleSuccessful, id)
	var i SyncLog
	err := row.Scan(
		&i.ID,
		&i.TransactionID,
		&i.WalletID,
		&i.Status,
		&i.AttemptCount,
		&i.LastAttemptAt,
		&i.ErrorMessage,
		&i.ConflictData,
		&i.ResolvedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const resolveSyncConflict = `-- name: ResolveSyncConflict :one
UPDATE sync_logs
SET 
    status = 'settled',
    resolved_at = NOW(),
    updated_at = NOW()
WHERE id = $1
RETURNING id, transaction_id, wallet_id, status, attempt_count, last_attempt_at, error_message, conflict_data, resolved_at, created_at, updated_at
`

func (q *Queries) ResolveSyncConflict(ctx context.Context, id uuid.UUID) (SyncLog, error) {
	row := q.db.QueryRow(ctx, resolveSyncConflict, id)
	var i SyncLog
	err := row.Scan(
		&i.ID,
		&i.TransactionID,
		&i.WalletID,
		&i.Status,
		&i.AttemptCount,
		&i.LastAttemptAt,
		&i.ErrorMessage,
		&i.ConflictData,
		&i.ResolvedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateSyncLogStatus = `-- name: UpdateSyncLogStatus :one
UPDATE sync_logs
SET 
    status = $2,
    last_attempt_at = NOW(),
    attempt_count = attempt_count + 1,
    updated_at = NOW()
WHERE id = $1
RETURNING id, transaction_id, wallet_id, status, attempt_count, last_attempt_at, error_message, conflict_data, resolved_at, created_at, updated_at
`

type UpdateSyncLogStatusParams struct {
	ID     uuid.UUID  `json:"id"`
	Status SyncStatus `json:"status"`
}

func (q *Queries) UpdateSyncLogStatus(ctx context.Context, arg UpdateSyncLogStatusParams) (SyncLog, error) {
	row := q.db.QueryRow(ctx, updateSyncLogStatus, arg.ID, arg.Status)
	var i SyncLog
	err := row.Scan(
		&i.ID,
		&i.TransactionID,
		&i.WalletID,
		&i.Status,
		&i.AttemptCount,
		&i.LastAttemptAt,
		&i.ErrorMessage,
		&i.ConflictData,
		&i.ResolvedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
