// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: wallets.sql

package database

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const activateWallet = `-- name: ActivateWallet :exec
UPDATE wallets
SET
is_active = TRUE,
updated_at = NOW()
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) ActivateWallet(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, activateWallet, id)
	return err
}

const countWallets = `-- name: CountWallets :one
SELECT COUNT(*) AS count
FROM wallets
WHERE is_active = TRUE AND deleted_at IS NULL
`

func (q *Queries) CountWallets(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countWallets)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createWallet = `-- name: CreateWallet :one

INSERT INTO wallets (
user_id,
public_key,
private_key,
balance,
phone_number,
name,
pin_hash,
device_id
) VALUES (
	$1, $2, $3, $4, $5, $6, $7, $8
	) RETURNING id, public_key, private_key, balance, phone_number, name, pin_hash, is_active, device_id, last_synced_at, created_at, updated_at, deleted_at, user_id
`

type CreateWalletParams struct {
	UserID      pgtype.UUID    `json:"user_id"`
	PublicKey   string         `json:"public_key"`
	PrivateKey  string         `json:"private_key"`
	Balance     pgtype.Numeric `json:"balance"`
	PhoneNumber string         `json:"phone_number"`
	Name        string         `json:"name"`
	PinHash     string         `json:"pin_hash"`
	DeviceID    *string        `json:"device_id"`
}

// internal/database/query/wallets.sql
func (q *Queries) CreateWallet(ctx context.Context, arg CreateWalletParams) (Wallet, error) {
	row := q.db.QueryRow(ctx, createWallet,
		arg.UserID,
		arg.PublicKey,
		arg.PrivateKey,
		arg.Balance,
		arg.PhoneNumber,
		arg.Name,
		arg.PinHash,
		arg.DeviceID,
	)
	var i Wallet
	err := row.Scan(
		&i.ID,
		&i.PublicKey,
		&i.PrivateKey,
		&i.Balance,
		&i.PhoneNumber,
		&i.Name,
		&i.PinHash,
		&i.IsActive,
		&i.DeviceID,
		&i.LastSyncedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.UserID,
	)
	return i, err
}

const deactivateWallet = `-- name: DeactivateWallet :exec
UPDATE wallets
SET
is_active = FALSE,
updated_at = NOW()
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) DeactivateWallet(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deactivateWallet, id)
	return err
}

const decrementWalletBalance = `-- name: DecrementWalletBalance :one
UPDATE wallets
SET
balance = balance - $2,
updated_at = NOW()
WHERE id = $1 AND deleted_at IS NULL AND balance >= $2
RETURNING id, public_key, private_key, balance, phone_number, name, pin_hash, is_active, device_id, last_synced_at, created_at, updated_at, deleted_at, user_id
`

type DecrementWalletBalanceParams struct {
	ID      uuid.UUID      `json:"id"`
	Balance pgtype.Numeric `json:"balance"`
}

func (q *Queries) DecrementWalletBalance(ctx context.Context, arg DecrementWalletBalanceParams) (Wallet, error) {
	row := q.db.QueryRow(ctx, decrementWalletBalance, arg.ID, arg.Balance)
	var i Wallet
	err := row.Scan(
		&i.ID,
		&i.PublicKey,
		&i.PrivateKey,
		&i.Balance,
		&i.PhoneNumber,
		&i.Name,
		&i.PinHash,
		&i.IsActive,
		&i.DeviceID,
		&i.LastSyncedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.UserID,
	)
	return i, err
}

const getWalletBalance = `-- name: GetWalletBalance :one
SELECT balance FROM wallets
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetWalletBalance(ctx context.Context, id uuid.UUID) (pgtype.Numeric, error) {
	row := q.db.QueryRow(ctx, getWalletBalance, id)
	var balance pgtype.Numeric
	err := row.Scan(&balance)
	return balance, err
}

const getWalletByDeviceID = `-- name: GetWalletByDeviceID :one
SELECT id, public_key, private_key, balance, phone_number, name, pin_hash, is_active, device_id, last_synced_at, created_at, updated_at, deleted_at, user_id FROM wallets WHERE device_id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetWalletByDeviceID(ctx context.Context, deviceID *string) (Wallet, error) {
	row := q.db.QueryRow(ctx, getWalletByDeviceID, deviceID)
	var i Wallet
	err := row.Scan(
		&i.ID,
		&i.PublicKey,
		&i.PrivateKey,
		&i.Balance,
		&i.PhoneNumber,
		&i.Name,
		&i.PinHash,
		&i.IsActive,
		&i.DeviceID,
		&i.LastSyncedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.UserID,
	)
	return i, err
}

const getWalletByID = `-- name: GetWalletByID :one
SELECT id, public_key, private_key, balance, phone_number, name, pin_hash, is_active, device_id, last_synced_at, created_at, updated_at, deleted_at, user_id FROM wallets WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetWalletByID(ctx context.Context, id uuid.UUID) (Wallet, error) {
	row := q.db.QueryRow(ctx, getWalletByID, id)
	var i Wallet
	err := row.Scan(
		&i.ID,
		&i.PublicKey,
		&i.PrivateKey,
		&i.Balance,
		&i.PhoneNumber,
		&i.Name,
		&i.PinHash,
		&i.IsActive,
		&i.DeviceID,
		&i.LastSyncedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.UserID,
	)
	return i, err
}

const getWalletByPhoneNumber = `-- name: GetWalletByPhoneNumber :one
SELECT id, public_key, private_key, balance, phone_number, name, pin_hash, is_active, device_id, last_synced_at, created_at, updated_at, deleted_at, user_id FROM wallets WHERE phone_number = $1 AND deleted_at IS NULL
`

func (q *Queries) GetWalletByPhoneNumber(ctx context.Context, phoneNumber string) (Wallet, error) {
	row := q.db.QueryRow(ctx, getWalletByPhoneNumber, phoneNumber)
	var i Wallet
	err := row.Scan(
		&i.ID,
		&i.PublicKey,
		&i.PrivateKey,
		&i.Balance,
		&i.PhoneNumber,
		&i.Name,
		&i.PinHash,
		&i.IsActive,
		&i.DeviceID,
		&i.LastSyncedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.UserID,
	)
	return i, err
}

const getWalletByPublicKey = `-- name: GetWalletByPublicKey :one
SELECT id, public_key, private_key, balance, phone_number, name, pin_hash, is_active, device_id, last_synced_at, created_at, updated_at, deleted_at, user_id FROM wallets WHERE public_key = $1 AND deleted_at IS NULL
`

func (q *Queries) GetWalletByPublicKey(ctx context.Context, publicKey string) (Wallet, error) {
	row := q.db.QueryRow(ctx, getWalletByPublicKey, publicKey)
	var i Wallet
	err := row.Scan(
		&i.ID,
		&i.PublicKey,
		&i.PrivateKey,
		&i.Balance,
		&i.PhoneNumber,
		&i.Name,
		&i.PinHash,
		&i.IsActive,
		&i.DeviceID,
		&i.LastSyncedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.UserID,
	)
	return i, err
}

const getWalletWithBalance = `-- name: GetWalletWithBalance :one
SELECT id, name, phone_number, balance, is_active, created_at
FROM wallets
WHERE id = $1 AND deleted_at IS NULL
`

type GetWalletWithBalanceRow struct {
	ID          uuid.UUID          `json:"id"`
	Name        string             `json:"name"`
	PhoneNumber string             `json:"phone_number"`
	Balance     pgtype.Numeric     `json:"balance"`
	IsActive    *bool              `json:"is_active"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) GetWalletWithBalance(ctx context.Context, id uuid.UUID) (GetWalletWithBalanceRow, error) {
	row := q.db.QueryRow(ctx, getWalletWithBalance, id)
	var i GetWalletWithBalanceRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.PhoneNumber,
		&i.Balance,
		&i.IsActive,
		&i.CreatedAt,
	)
	return i, err
}

const getWalletsNeedingSync = `-- name: GetWalletsNeedingSync :many
SELECT id, public_key, private_key, balance, phone_number, name, pin_hash, is_active, device_id, last_synced_at, created_at, updated_at, deleted_at, user_id FROM wallets
WHERE (last_synced_at IS NULL OR last_synced_at < NOW() - INTERVAL '1 day')
	AND deleted_at IS NULL
ORDER BY last_synced_at ASC NULLS FIRST
LIMIT $1
`

func (q *Queries) GetWalletsNeedingSync(ctx context.Context, limit int32) ([]Wallet, error) {
	rows, err := q.db.Query(ctx, getWalletsNeedingSync, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Wallet{}
	for rows.Next() {
		var i Wallet
		if err := rows.Scan(
			&i.ID,
			&i.PublicKey,
			&i.PrivateKey,
			&i.Balance,
			&i.PhoneNumber,
			&i.Name,
			&i.PinHash,
			&i.IsActive,
			&i.DeviceID,
			&i.LastSyncedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const hardDeleteWallet = `-- name: HardDeleteWallet :exec
DELETE FROM wallets
WHERE id = $1
`

func (q *Queries) HardDeleteWallet(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, hardDeleteWallet, id)
	return err
}

const incrementWalletBalance = `-- name: IncrementWalletBalance :one
UPDATE wallets
SET
balance = balance + $2,
updated_at = NOW()
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, public_key, private_key, balance, phone_number, name, pin_hash, is_active, device_id, last_synced_at, created_at, updated_at, deleted_at, user_id
`

type IncrementWalletBalanceParams struct {
	ID      uuid.UUID      `json:"id"`
	Balance pgtype.Numeric `json:"balance"`
}

func (q *Queries) IncrementWalletBalance(ctx context.Context, arg IncrementWalletBalanceParams) (Wallet, error) {
	row := q.db.QueryRow(ctx, incrementWalletBalance, arg.ID, arg.Balance)
	var i Wallet
	err := row.Scan(
		&i.ID,
		&i.PublicKey,
		&i.PrivateKey,
		&i.Balance,
		&i.PhoneNumber,
		&i.Name,
		&i.PinHash,
		&i.IsActive,
		&i.DeviceID,
		&i.LastSyncedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.UserID,
	)
	return i, err
}

const listActiveWallets = `-- name: ListActiveWallets :many
SELECT id, public_key, private_key, balance, phone_number, name, pin_hash, is_active, device_id, last_synced_at, created_at, updated_at, deleted_at, user_id FROM wallets WHERE is_active = TRUE AND deleted_at IS NULL ORDER BY created_at DESC LIMIT $1 OFFSET $2
`

type ListActiveWalletsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListActiveWallets(ctx context.Context, arg ListActiveWalletsParams) ([]Wallet, error) {
	rows, err := q.db.Query(ctx, listActiveWallets, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Wallet{}
	for rows.Next() {
		var i Wallet
		if err := rows.Scan(
			&i.ID,
			&i.PublicKey,
			&i.PrivateKey,
			&i.Balance,
			&i.PhoneNumber,
			&i.Name,
			&i.PinHash,
			&i.IsActive,
			&i.DeviceID,
			&i.LastSyncedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWallets = `-- name: ListWallets :many
SELECT id, public_key, private_key, balance, phone_number, name, pin_hash, is_active, device_id, last_synced_at, created_at, updated_at, deleted_at, user_id FROM wallets WHERE deleted_at IS NULL ORDER BY created_at DESC LIMIT $1 OFFSET $2
`

type ListWalletsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListWallets(ctx context.Context, arg ListWalletsParams) ([]Wallet, error) {
	rows, err := q.db.Query(ctx, listWallets, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Wallet{}
	for rows.Next() {
		var i Wallet
		if err := rows.Scan(
			&i.ID,
			&i.PublicKey,
			&i.PrivateKey,
			&i.Balance,
			&i.PhoneNumber,
			&i.Name,
			&i.PinHash,
			&i.IsActive,
			&i.DeviceID,
			&i.LastSyncedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchWalletsByName = `-- name: SearchWalletsByName :many
SELECT id, name, phone_number, balance, is_active, created_at
FROM wallets
WHERE name ILIKE '%' || $1 || '%' 
	AND deleted_at IS NULL
	AND is_active = TRUE
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type SearchWalletsByNameParams struct {
	Column1 *string `json:"column_1"`
	Limit   int32   `json:"limit"`
	Offset  int32   `json:"offset"`
}

type SearchWalletsByNameRow struct {
	ID          uuid.UUID          `json:"id"`
	Name        string             `json:"name"`
	PhoneNumber string             `json:"phone_number"`
	Balance     pgtype.Numeric     `json:"balance"`
	IsActive    *bool              `json:"is_active"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) SearchWalletsByName(ctx context.Context, arg SearchWalletsByNameParams) ([]SearchWalletsByNameRow, error) {
	rows, err := q.db.Query(ctx, searchWalletsByName, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchWalletsByNameRow{}
	for rows.Next() {
		var i SearchWalletsByNameRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.PhoneNumber,
			&i.Balance,
			&i.IsActive,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchWalletsByPhoneNumber = `-- name: SearchWalletsByPhoneNumber :many
SELECT id, name, phone_number, balance, is_active, created_at
FROM wallets
WHERE phone_number ILIKE '%' || $1 || '%'
	AND deleted_at IS NULL
	AND is_active = TRUE
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type SearchWalletsByPhoneNumberParams struct {
	Column1 *string `json:"column_1"`
	Limit   int32   `json:"limit"`
	Offset  int32   `json:"offset"`
}

type SearchWalletsByPhoneNumberRow struct {
	ID          uuid.UUID          `json:"id"`
	Name        string             `json:"name"`
	PhoneNumber string             `json:"phone_number"`
	Balance     pgtype.Numeric     `json:"balance"`
	IsActive    *bool              `json:"is_active"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) SearchWalletsByPhoneNumber(ctx context.Context, arg SearchWalletsByPhoneNumberParams) ([]SearchWalletsByPhoneNumberRow, error) {
	rows, err := q.db.Query(ctx, searchWalletsByPhoneNumber, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchWalletsByPhoneNumberRow{}
	for rows.Next() {
		var i SearchWalletsByPhoneNumberRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.PhoneNumber,
			&i.Balance,
			&i.IsActive,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const softDeleteWallet = `-- name: SoftDeleteWallet :exec
UPDATE wallets
SET
deleted_at = NOW(),
is_active = FALSE,
updated_at = NOW()
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) SoftDeleteWallet(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, softDeleteWallet, id)
	return err
}

const updateWallet = `-- name: UpdateWallet :one
UPDATE wallets
SET
name = COALESCE($2, name),
phone_number = COALESCE($3, phone_number),
device_id = COALESCE($4, device_id),
updated_at = NOW()
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, public_key, private_key, balance, phone_number, name, pin_hash, is_active, device_id, last_synced_at, created_at, updated_at, deleted_at, user_id
`

type UpdateWalletParams struct {
	ID          uuid.UUID `json:"id"`
	Name        *string   `json:"name"`
	PhoneNumber *string   `json:"phone_number"`
	DeviceID    *string   `json:"device_id"`
}

func (q *Queries) UpdateWallet(ctx context.Context, arg UpdateWalletParams) (Wallet, error) {
	row := q.db.QueryRow(ctx, updateWallet,
		arg.ID,
		arg.Name,
		arg.PhoneNumber,
		arg.DeviceID,
	)
	var i Wallet
	err := row.Scan(
		&i.ID,
		&i.PublicKey,
		&i.PrivateKey,
		&i.Balance,
		&i.PhoneNumber,
		&i.Name,
		&i.PinHash,
		&i.IsActive,
		&i.DeviceID,
		&i.LastSyncedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.UserID,
	)
	return i, err
}

const updateWalletBalance = `-- name: UpdateWalletBalance :one
UPDATE wallets
SET
balance = $2,
updated_at = NOW()
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, public_key, private_key, balance, phone_number, name, pin_hash, is_active, device_id, last_synced_at, created_at, updated_at, deleted_at, user_id
`

type UpdateWalletBalanceParams struct {
	ID      uuid.UUID      `json:"id"`
	Balance pgtype.Numeric `json:"balance"`
}

func (q *Queries) UpdateWalletBalance(ctx context.Context, arg UpdateWalletBalanceParams) (Wallet, error) {
	row := q.db.QueryRow(ctx, updateWalletBalance, arg.ID, arg.Balance)
	var i Wallet
	err := row.Scan(
		&i.ID,
		&i.PublicKey,
		&i.PrivateKey,
		&i.Balance,
		&i.PhoneNumber,
		&i.Name,
		&i.PinHash,
		&i.IsActive,
		&i.DeviceID,
		&i.LastSyncedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.UserID,
	)
	return i, err
}

const updateWalletLastSync = `-- name: UpdateWalletLastSync :exec
UPDATE wallets
SET
last_synced_at = NOW(),
updated_at = NOW()
WHERE id = $1
`

func (q *Queries) UpdateWalletLastSync(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, updateWalletLastSync, id)
	return err
}

const updateWalletPIN = `-- name: UpdateWalletPIN :exec
UPDATE wallets
SET
pin_hash = $2,
updated_at = NOW()
WHERE id = $1 AND deleted_at IS NULL
`

type UpdateWalletPINParams struct {
	ID      uuid.UUID `json:"id"`
	PinHash string    `json:"pin_hash"`
}

func (q *Queries) UpdateWalletPIN(ctx context.Context, arg UpdateWalletPINParams) error {
	_, err := q.db.Exec(ctx, updateWalletPIN, arg.ID, arg.PinHash)
	return err
}
