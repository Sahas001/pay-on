// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: audit_logs.sql

package database

import (
	"context"
	"net/netip"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countAuditLogs = `-- name: CountAuditLogs :one
SELECT COUNT(*) FROM audit_logs
`

func (q *Queries) CountAuditLogs(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countAuditLogs)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countAuditLogsByTable = `-- name: CountAuditLogsByTable :one
SELECT COUNT(*) FROM audit_logs
WHERE table_name = $1
`

func (q *Queries) CountAuditLogsByTable(ctx context.Context, tableName string) (int64, error) {
	row := q.db.QueryRow(ctx, countAuditLogsByTable, tableName)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createAuditLog = `-- name: CreateAuditLog :one

INSERT INTO audit_logs (
    table_name,
    record_id,
    action,
    old_data,
    new_data,
    changed_by,
    ip_address,
    user_agent
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
) RETURNING id, table_name, record_id, action, old_data, new_data, changed_by, changed_at, ip_address, user_agent
`

type CreateAuditLogParams struct {
	TableName string      `json:"table_name"`
	RecordID  uuid.UUID   `json:"record_id"`
	Action    string      `json:"action"`
	OldData   []byte      `json:"old_data"`
	NewData   []byte      `json:"new_data"`
	ChangedBy pgtype.UUID `json:"changed_by"`
	IpAddress *netip.Addr `json:"ip_address"`
	UserAgent *string     `json:"user_agent"`
}

// internal/database/query/audit_logs.sql
func (q *Queries) CreateAuditLog(ctx context.Context, arg CreateAuditLogParams) (AuditLog, error) {
	row := q.db.QueryRow(ctx, createAuditLog,
		arg.TableName,
		arg.RecordID,
		arg.Action,
		arg.OldData,
		arg.NewData,
		arg.ChangedBy,
		arg.IpAddress,
		arg.UserAgent,
	)
	var i AuditLog
	err := row.Scan(
		&i.ID,
		&i.TableName,
		&i.RecordID,
		&i.Action,
		&i.OldData,
		&i.NewData,
		&i.ChangedBy,
		&i.ChangedAt,
		&i.IpAddress,
		&i.UserAgent,
	)
	return i, err
}

const deleteOldAuditLogs = `-- name: DeleteOldAuditLogs :exec
DELETE FROM audit_logs
WHERE changed_at < NOW() - ($1 || ' days')::INTERVAL
`

func (q *Queries) DeleteOldAuditLogs(ctx context.Context, dollar_1 *string) error {
	_, err := q.db.Exec(ctx, deleteOldAuditLogs, dollar_1)
	return err
}

const getAuditLogByID = `-- name: GetAuditLogByID :one
SELECT id, table_name, record_id, action, old_data, new_data, changed_by, changed_at, ip_address, user_agent FROM audit_logs
WHERE id = $1
`

func (q *Queries) GetAuditLogByID(ctx context.Context, id uuid.UUID) (AuditLog, error) {
	row := q.db.QueryRow(ctx, getAuditLogByID, id)
	var i AuditLog
	err := row.Scan(
		&i.ID,
		&i.TableName,
		&i.RecordID,
		&i.Action,
		&i.OldData,
		&i.NewData,
		&i.ChangedBy,
		&i.ChangedAt,
		&i.IpAddress,
		&i.UserAgent,
	)
	return i, err
}

const getBalanceHistory = `-- name: GetBalanceHistory :many
SELECT 
    changed_at,
    old_data->>'balance' as old_balance,
    new_data->>'balance' as new_balance
FROM audit_logs
WHERE table_name = 'wallets'
  AND record_id = $1
  AND action = 'UPDATE'
  AND (old_data->>'balance' IS DISTINCT FROM new_data->>'balance')
ORDER BY changed_at DESC
LIMIT $2
`

type GetBalanceHistoryParams struct {
	RecordID uuid.UUID `json:"record_id"`
	Limit    int32     `json:"limit"`
}

type GetBalanceHistoryRow struct {
	ChangedAt  pgtype.Timestamptz `json:"changed_at"`
	OldBalance interface{}        `json:"old_balance"`
	NewBalance interface{}        `json:"new_balance"`
}

func (q *Queries) GetBalanceHistory(ctx context.Context, arg GetBalanceHistoryParams) ([]GetBalanceHistoryRow, error) {
	rows, err := q.db.Query(ctx, getBalanceHistory, arg.RecordID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetBalanceHistoryRow{}
	for rows.Next() {
		var i GetBalanceHistoryRow
		if err := rows.Scan(&i.ChangedAt, &i.OldBalance, &i.NewBalance); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentAuditLogs = `-- name: GetRecentAuditLogs :many
SELECT id, table_name, record_id, action, old_data, new_data, changed_by, changed_at, ip_address, user_agent FROM audit_logs
WHERE changed_at >= NOW() - INTERVAL '24 hours'
ORDER BY changed_at DESC
LIMIT $1
`

func (q *Queries) GetRecentAuditLogs(ctx context.Context, limit int32) ([]AuditLog, error) {
	rows, err := q.db.Query(ctx, getRecentAuditLogs, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AuditLog{}
	for rows.Next() {
		var i AuditLog
		if err := rows.Scan(
			&i.ID,
			&i.TableName,
			&i.RecordID,
			&i.Action,
			&i.OldData,
			&i.NewData,
			&i.ChangedBy,
			&i.ChangedAt,
			&i.IpAddress,
			&i.UserAgent,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecordHistory = `-- name: GetRecordHistory :many
SELECT id, table_name, record_id, action, old_data, new_data, changed_by, changed_at, ip_address, user_agent FROM audit_logs
WHERE table_name = $1 AND record_id = $2
ORDER BY changed_at ASC
`

type GetRecordHistoryParams struct {
	TableName string    `json:"table_name"`
	RecordID  uuid.UUID `json:"record_id"`
}

func (q *Queries) GetRecordHistory(ctx context.Context, arg GetRecordHistoryParams) ([]AuditLog, error) {
	rows, err := q.db.Query(ctx, getRecordHistory, arg.TableName, arg.RecordID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AuditLog{}
	for rows.Next() {
		var i AuditLog
		if err := rows.Scan(
			&i.ID,
			&i.TableName,
			&i.RecordID,
			&i.Action,
			&i.OldData,
			&i.NewData,
			&i.ChangedBy,
			&i.ChangedAt,
			&i.IpAddress,
			&i.UserAgent,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAuditLogs = `-- name: ListAuditLogs :many
SELECT id, table_name, record_id, action, old_data, new_data, changed_by, changed_at, ip_address, user_agent FROM audit_logs
ORDER BY changed_at DESC
LIMIT $1 OFFSET $2
`

type ListAuditLogsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListAuditLogs(ctx context.Context, arg ListAuditLogsParams) ([]AuditLog, error) {
	rows, err := q.db.Query(ctx, listAuditLogs, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AuditLog{}
	for rows.Next() {
		var i AuditLog
		if err := rows.Scan(
			&i.ID,
			&i.TableName,
			&i.RecordID,
			&i.Action,
			&i.OldData,
			&i.NewData,
			&i.ChangedBy,
			&i.ChangedAt,
			&i.IpAddress,
			&i.UserAgent,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAuditLogsByAction = `-- name: ListAuditLogsByAction :many
SELECT id, table_name, record_id, action, old_data, new_data, changed_by, changed_at, ip_address, user_agent FROM audit_logs
WHERE action = $1
ORDER BY changed_at DESC
LIMIT $2 OFFSET $3
`

type ListAuditLogsByActionParams struct {
	Action string `json:"action"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

func (q *Queries) ListAuditLogsByAction(ctx context.Context, arg ListAuditLogsByActionParams) ([]AuditLog, error) {
	rows, err := q.db.Query(ctx, listAuditLogsByAction, arg.Action, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AuditLog{}
	for rows.Next() {
		var i AuditLog
		if err := rows.Scan(
			&i.ID,
			&i.TableName,
			&i.RecordID,
			&i.Action,
			&i.OldData,
			&i.NewData,
			&i.ChangedBy,
			&i.ChangedAt,
			&i.IpAddress,
			&i.UserAgent,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAuditLogsByDateRange = `-- name: ListAuditLogsByDateRange :many
SELECT id, table_name, record_id, action, old_data, new_data, changed_by, changed_at, ip_address, user_agent FROM audit_logs
WHERE changed_at BETWEEN $1 AND $2
ORDER BY changed_at DESC
LIMIT $3 OFFSET $4
`

type ListAuditLogsByDateRangeParams struct {
	ChangedAt   pgtype.Timestamptz `json:"changed_at"`
	ChangedAt_2 pgtype.Timestamptz `json:"changed_at_2"`
	Limit       int32              `json:"limit"`
	Offset      int32              `json:"offset"`
}

func (q *Queries) ListAuditLogsByDateRange(ctx context.Context, arg ListAuditLogsByDateRangeParams) ([]AuditLog, error) {
	rows, err := q.db.Query(ctx, listAuditLogsByDateRange,
		arg.ChangedAt,
		arg.ChangedAt_2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AuditLog{}
	for rows.Next() {
		var i AuditLog
		if err := rows.Scan(
			&i.ID,
			&i.TableName,
			&i.RecordID,
			&i.Action,
			&i.OldData,
			&i.NewData,
			&i.ChangedBy,
			&i.ChangedAt,
			&i.IpAddress,
			&i.UserAgent,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAuditLogsByIP = `-- name: ListAuditLogsByIP :many
SELECT id, table_name, record_id, action, old_data, new_data, changed_by, changed_at, ip_address, user_agent FROM audit_logs
WHERE ip_address = $1
ORDER BY changed_at DESC
LIMIT $2 OFFSET $3
`

type ListAuditLogsByIPParams struct {
	IpAddress *netip.Addr `json:"ip_address"`
	Limit     int32       `json:"limit"`
	Offset    int32       `json:"offset"`
}

func (q *Queries) ListAuditLogsByIP(ctx context.Context, arg ListAuditLogsByIPParams) ([]AuditLog, error) {
	rows, err := q.db.Query(ctx, listAuditLogsByIP, arg.IpAddress, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AuditLog{}
	for rows.Next() {
		var i AuditLog
		if err := rows.Scan(
			&i.ID,
			&i.TableName,
			&i.RecordID,
			&i.Action,
			&i.OldData,
			&i.NewData,
			&i.ChangedBy,
			&i.ChangedAt,
			&i.IpAddress,
			&i.UserAgent,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAuditLogsByRecord = `-- name: ListAuditLogsByRecord :many
SELECT id, table_name, record_id, action, old_data, new_data, changed_by, changed_at, ip_address, user_agent FROM audit_logs
WHERE table_name = $1 AND record_id = $2
ORDER BY changed_at DESC
`

type ListAuditLogsByRecordParams struct {
	TableName string    `json:"table_name"`
	RecordID  uuid.UUID `json:"record_id"`
}

func (q *Queries) ListAuditLogsByRecord(ctx context.Context, arg ListAuditLogsByRecordParams) ([]AuditLog, error) {
	rows, err := q.db.Query(ctx, listAuditLogsByRecord, arg.TableName, arg.RecordID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AuditLog{}
	for rows.Next() {
		var i AuditLog
		if err := rows.Scan(
			&i.ID,
			&i.TableName,
			&i.RecordID,
			&i.Action,
			&i.OldData,
			&i.NewData,
			&i.ChangedBy,
			&i.ChangedAt,
			&i.IpAddress,
			&i.UserAgent,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAuditLogsByTable = `-- name: ListAuditLogsByTable :many
SELECT id, table_name, record_id, action, old_data, new_data, changed_by, changed_at, ip_address, user_agent FROM audit_logs
WHERE table_name = $1
ORDER BY changed_at DESC
LIMIT $2 OFFSET $3
`

type ListAuditLogsByTableParams struct {
	TableName string `json:"table_name"`
	Limit     int32  `json:"limit"`
	Offset    int32  `json:"offset"`
}

func (q *Queries) ListAuditLogsByTable(ctx context.Context, arg ListAuditLogsByTableParams) ([]AuditLog, error) {
	rows, err := q.db.Query(ctx, listAuditLogsByTable, arg.TableName, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AuditLog{}
	for rows.Next() {
		var i AuditLog
		if err := rows.Scan(
			&i.ID,
			&i.TableName,
			&i.RecordID,
			&i.Action,
			&i.OldData,
			&i.NewData,
			&i.ChangedBy,
			&i.ChangedAt,
			&i.IpAddress,
			&i.UserAgent,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAuditLogsByUser = `-- name: ListAuditLogsByUser :many
SELECT id, table_name, record_id, action, old_data, new_data, changed_by, changed_at, ip_address, user_agent FROM audit_logs
WHERE changed_by = $1
ORDER BY changed_at DESC
LIMIT $2 OFFSET $3
`

type ListAuditLogsByUserParams struct {
	ChangedBy pgtype.UUID `json:"changed_by"`
	Limit     int32       `json:"limit"`
	Offset    int32       `json:"offset"`
}

func (q *Queries) ListAuditLogsByUser(ctx context.Context, arg ListAuditLogsByUserParams) ([]AuditLog, error) {
	rows, err := q.db.Query(ctx, listAuditLogsByUser, arg.ChangedBy, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AuditLog{}
	for rows.Next() {
		var i AuditLog
		if err := rows.Scan(
			&i.ID,
			&i.TableName,
			&i.RecordID,
			&i.Action,
			&i.OldData,
			&i.NewData,
			&i.ChangedBy,
			&i.ChangedAt,
			&i.IpAddress,
			&i.UserAgent,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
