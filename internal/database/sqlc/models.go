// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0

package database

import (
	"database/sql/driver"
	"fmt"
	"net"
	"net/netip"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

type ConnectionType string

const (
	ConnectionTypeLan       ConnectionType = "lan"
	ConnectionTypeBluetooth ConnectionType = "bluetooth"
	ConnectionTypeOnline    ConnectionType = "online"
)

func (e *ConnectionType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ConnectionType(s)
	case string:
		*e = ConnectionType(s)
	default:
		return fmt.Errorf("unsupported scan type for ConnectionType: %T", src)
	}
	return nil
}

type NullConnectionType struct {
	ConnectionType ConnectionType `json:"connection_type"`
	Valid          bool           `json:"valid"` // Valid is true if ConnectionType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullConnectionType) Scan(value interface{}) error {
	if value == nil {
		ns.ConnectionType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ConnectionType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullConnectionType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ConnectionType), nil
}

func (e ConnectionType) Valid() bool {
	switch e {
	case ConnectionTypeLan,
		ConnectionTypeBluetooth,
		ConnectionTypeOnline:
		return true
	}
	return false
}

func AllConnectionTypeValues() []ConnectionType {
	return []ConnectionType{
		ConnectionTypeLan,
		ConnectionTypeBluetooth,
		ConnectionTypeOnline,
	}
}

type SyncStatus string

const (
	SyncStatusPending   SyncStatus = "pending"
	SyncStatusConfirmed SyncStatus = "confirmed"
	SyncStatusSettling  SyncStatus = "settling"
	SyncStatusSettled   SyncStatus = "settled"
	SyncStatusFailed    SyncStatus = "failed"
	SyncStatusConflict  SyncStatus = "conflict"
)

func (e *SyncStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = SyncStatus(s)
	case string:
		*e = SyncStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for SyncStatus: %T", src)
	}
	return nil
}

type NullSyncStatus struct {
	SyncStatus SyncStatus `json:"sync_status"`
	Valid      bool       `json:"valid"` // Valid is true if SyncStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullSyncStatus) Scan(value interface{}) error {
	if value == nil {
		ns.SyncStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.SyncStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullSyncStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.SyncStatus), nil
}

func (e SyncStatus) Valid() bool {
	switch e {
	case SyncStatusPending,
		SyncStatusConfirmed,
		SyncStatusSettling,
		SyncStatusSettled,
		SyncStatusFailed,
		SyncStatusConflict:
		return true
	}
	return false
}

func AllSyncStatusValues() []SyncStatus {
	return []SyncStatus{
		SyncStatusPending,
		SyncStatusConfirmed,
		SyncStatusSettling,
		SyncStatusSettled,
		SyncStatusFailed,
		SyncStatusConflict,
	}
}

type TransactionStatus string

const (
	TransactionStatusPending    TransactionStatus = "pending"
	TransactionStatusConfirmed  TransactionStatus = "confirmed"
	TransactionStatusSettling   TransactionStatus = "settling"
	TransactionStatusSettled    TransactionStatus = "settled"
	TransactionStatusFailed     TransactionStatus = "failed"
	TransactionStatusRolledBack TransactionStatus = "rolled_back"
)

func (e *TransactionStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = TransactionStatus(s)
	case string:
		*e = TransactionStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for TransactionStatus: %T", src)
	}
	return nil
}

type NullTransactionStatus struct {
	TransactionStatus TransactionStatus `json:"transaction_status"`
	Valid             bool              `json:"valid"` // Valid is true if TransactionStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullTransactionStatus) Scan(value interface{}) error {
	if value == nil {
		ns.TransactionStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.TransactionStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullTransactionStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.TransactionStatus), nil
}

func (e TransactionStatus) Valid() bool {
	switch e {
	case TransactionStatusPending,
		TransactionStatusConfirmed,
		TransactionStatusSettling,
		TransactionStatusSettled,
		TransactionStatusFailed,
		TransactionStatusRolledBack:
		return true
	}
	return false
}

func AllTransactionStatusValues() []TransactionStatus {
	return []TransactionStatus{
		TransactionStatusPending,
		TransactionStatusConfirmed,
		TransactionStatusSettling,
		TransactionStatusSettled,
		TransactionStatusFailed,
		TransactionStatusRolledBack,
	}
}

type TransactionType string

const (
	TransactionTypeP2p      TransactionType = "p2p"
	TransactionTypeDeposit  TransactionType = "deposit"
	TransactionTypeWithdraw TransactionType = "withdraw"
)

func (e *TransactionType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = TransactionType(s)
	case string:
		*e = TransactionType(s)
	default:
		return fmt.Errorf("unsupported scan type for TransactionType: %T", src)
	}
	return nil
}

type NullTransactionType struct {
	TransactionType TransactionType `json:"transaction_type"`
	Valid           bool            `json:"valid"` // Valid is true if TransactionType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullTransactionType) Scan(value interface{}) error {
	if value == nil {
		ns.TransactionType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.TransactionType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullTransactionType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.TransactionType), nil
}

func (e TransactionType) Valid() bool {
	switch e {
	case TransactionTypeP2p,
		TransactionTypeDeposit,
		TransactionTypeWithdraw:
		return true
	}
	return false
}

func AllTransactionTypeValues() []TransactionType {
	return []TransactionType{
		TransactionTypeP2p,
		TransactionTypeDeposit,
		TransactionTypeWithdraw,
	}
}

// Audit trail for all data modifications
type AuditLog struct {
	ID        uuid.UUID          `json:"id"`
	TableName string             `json:"table_name"`
	RecordID  uuid.UUID          `json:"record_id"`
	Action    string             `json:"action"`
	OldData   []byte             `json:"old_data"`
	NewData   []byte             `json:"new_data"`
	ChangedBy pgtype.UUID        `json:"changed_by"`
	ChangedAt pgtype.Timestamptz `json:"changed_at"`
	IpAddress *netip.Addr        `json:"ip_address"`
	UserAgent *string            `json:"user_agent"`
}

// Known peers for each wallet with connection history
type Peer struct {
	ID               uuid.UUID          `json:"id"`
	WalletID         uuid.UUID          `json:"wallet_id"`
	PeerWalletID     uuid.UUID          `json:"peer_wallet_id"`
	Name             *string            `json:"name"`
	PublicKey        string             `json:"public_key"`
	IpAddress        *netip.Addr        `json:"ip_address"`
	BtAddress        net.HardwareAddr   `json:"bt_address"`
	ConnectionType   ConnectionType     `json:"connection_type"`
	IsTrusted        *bool              `json:"is_trusted"`
	TransactionCount *int32             `json:"transaction_count"`
	LastSeenAt       pgtype.Timestamptz `json:"last_seen_at"`
	FirstSeenAt      pgtype.Timestamptz `json:"first_seen_at"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
	UpdatedAt        pgtype.Timestamptz `json:"updated_at"`
	DeletedAt        pgtype.Timestamptz `json:"deleted_at"`
}

// Synchronization logs for offline transactions
type SyncLog struct {
	ID            uuid.UUID          `json:"id"`
	TransactionID uuid.UUID          `json:"transaction_id"`
	WalletID      uuid.UUID          `json:"wallet_id"`
	Status        SyncStatus         `json:"status"`
	AttemptCount  *int32             `json:"attempt_count"`
	LastAttemptAt pgtype.Timestamptz `json:"last_attempt_at"`
	ErrorMessage  *string            `json:"error_message"`
	ConflictData  []byte             `json:"conflict_data"`
	ResolvedAt    pgtype.Timestamptz `json:"resolved_at"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
	UpdatedAt     pgtype.Timestamptz `json:"updated_at"`
}

// All payment transactions between wallets
type Transaction struct {
	ID           uuid.UUID         `json:"id"`
	FromWalletID uuid.UUID         `json:"from_wallet_id"`
	ToWalletID   uuid.UUID         `json:"to_wallet_id"`
	Amount       pgtype.Numeric    `json:"amount"`
	Currency     string            `json:"currency"`
	Type         TransactionType   `json:"type"`
	Status       TransactionStatus `json:"status"`
	// ECDSA signature of transaction data
	Signature string `json:"signature"`
	// Unique nonce per wallet for replay attack prevention
	Nonce          int64              `json:"nonce"`
	ConnectionType NullConnectionType `json:"connection_type"`
	Description    *string            `json:"description"`
	Metadata       []byte             `json:"metadata"`
	TransactionAt  pgtype.Timestamptz `json:"transaction_at"`
	ConfirmedAt    pgtype.Timestamptz `json:"confirmed_at"`
	SyncedAt       pgtype.Timestamptz `json:"synced_at"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	UpdatedAt      pgtype.Timestamptz `json:"updated_at"`
}

// User wallet information with cryptographic keys and balance
type Wallet struct {
	ID         uuid.UUID `json:"id"`
	PublicKey  string    `json:"public_key"`
	PrivateKey string    `json:"private_key"`
	// Current balance in NPR (Nepali Rupees)
	Balance     pgtype.Numeric `json:"balance"`
	PhoneNumber string         `json:"phone_number"`
	Name        string         `json:"name"`
	// Bcrypt hash of user PIN
	PinHash      string             `json:"pin_hash"`
	IsActive     *bool              `json:"is_active"`
	DeviceID     *string            `json:"device_id"`
	LastSyncedAt pgtype.Timestamptz `json:"last_synced_at"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
	UpdatedAt    pgtype.Timestamptz `json:"updated_at"`
	DeletedAt    pgtype.Timestamptz `json:"deleted_at"`
}
